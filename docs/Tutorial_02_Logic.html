<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Programming with Refinement Types</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Tutorial_01_Introduction.html'><b>1.</b>Introduction {#intro}</a></li>
<ul class='section'>
<li><a href='Tutorial_01_Introduction.html#'><b>1.1.</b> Well-Typed Programs Do Go Wrong {#gowrong}</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.2.</b> Refinement Types</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.3.</b> Audience</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.4.</b> Getting Started</a></li>
</ul>
<li><a href='Tutorial_02_Logic.html'><b>2.</b>Logic &amp; SMT</a></li>
<ul class='section'>
<li><a href='Tutorial_02_Logic.html#'><b>2.1.</b> Syntax</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.2.</b> Semantics {#semantics}</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.3.</b> Verification Conditions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.4.</b> Examples: Propositions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.5.</b> Examples: Arithmetic</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.6.</b> Examples: Uninterpreted Function</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_03_Basic.html'><b>3.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Tutorial_03_Basic.html#'><b>3.1.</b> Defining Types {#definetype}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.2.</b> Errors</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.3.</b> Subtyping</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.4.</b> Writing Specifications</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.5.</b> Refining Function Types: Pre-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.6.</b> Refining Function Types: Post-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.7.</b> Testing Values: Booleans and Propositions {#propositions}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.8.</b> Putting It All Together</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.9.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_04_Polymorphism.html'><b>4.</b>Polymorphism {#polymorphism}</a></li>
<ul class='section'>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.1.</b> Specification: Vector Bounds {#vectorbounds}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.2.</b> Verification: Vector Lookup</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.3.</b> Inference: Our First Recursive Function</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.4.</b> Higher-Order Functions: Bottling Recursion in a <code>loop</code></a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.5.</b> Refinements and Polymorphism {#sparsetype}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.6.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_05_Datatypes.html'><b>5.</b>Refined Datatypes {#refineddatatypes}</a></li>
<ul class='section'>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.1.</b> Sparse Vectors Revisited {#autosmart}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.2.</b> Ordered Lists {#orderedlists}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.3.</b> Ordered Trees {#binarysearchtree}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_06_Measure_Bool.html'><b>6.</b>Boolean Measures {#boolmeasures}</a></li>
<ul class='section'>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.1.</b> Partial Functions</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.2.</b> Lifting Functions to Measures {#usingmeasures}</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.3.</b> A Safe List API</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_07_Measure_Int.html'><b>7.</b>Numeric Measures {#numericmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.1.</b> Wholemeal Programming</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.2.</b> Specifying List Dimensions</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.3.</b> Lists: Size Preserving API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.4.</b> Lists: Size Reducing API {#listreducing}</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.5.</b> Dimension Safe Vector API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.6.</b> Dimension Safe Matrix API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_08_Measure_Set.html'><b>8.</b>Elemental Measures {#setmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.1.</b> Talking about Sets</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.2.</b> Proving QuickCheck Style Properties {#quickcheck}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.3.</b> Content-Aware List API {#listelems}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.4.</b> Permutations</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.5.</b> Uniqueness</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.6.</b> Unique Zippers</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html'><b>9.</b>Case Study: Okasaki's Lazy Queues {#lazyqueue}</a></li>
<ul class='section'>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.1.</b> Queues</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.2.</b> Sized Lists</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.3.</b> Queue Type</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.4.</b> Queue Operations</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.5.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html'><b>10.</b>Case Study: Associative Maps</a></li>
<ul class='section'>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.1.</b> Specifying Maps {#mapapi}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.2.</b> Using Maps: Well Scoped Expressions</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.3.</b> Implementing Maps: Binary Search Trees {#lemmas}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_11_Case_Study_Pointers.html'><b>11.</b>Case Study: Pointers &amp; Bytes {#case-study-pointers}</a></li>
<ul class='section'>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.1.</b> HeartBleeds in Haskell</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.2.</b> Low-level Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.3.</b> A Refined Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.4.</b> Assumptions vs Guarantees</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.5.</b> ByteString API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.6.</b> Application API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.7.</b> Nested ByteStrings</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.8.</b> Recap: Types Against Overflows</a></li>
</ul>
<li><a href='Tutorial_12_Case_Study_AVL.html'><b>12.</b>Case Study: AVL Trees {#case-study-avltree}</a></li>
<ul class='section'>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.1.</b> AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.2.</b> Specifying AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.3.</b> Smart Constructors</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.4.</b> Inserting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.5.</b> Rebalancing Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.6.</b> Refactoring Rebalance</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.7.</b> Deleting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.8.</b> Functional Correctness</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="logic-smt" class="level1">
<h1>Logic &amp; SMT</h1>
<div class="hidden">
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{-@ LIQUID "--short-names"         @-}
{-@ LIQUID "--no-termination"      @-}
{-@ LIQUID "--reflection"          @-}

module Tutorial_02_Logic where

{- size  :: xs:[a] -> {v:Int | v = size xs} @-}

ax1 :: Int -> Bool
ax2 :: Int -> Bool
ax3 :: Int -> Int -> Bool
ax4 :: Int -> Int -> Bool
ax5 :: Int -> Int -> Int -> Bool
ax6 :: Int -> Int -> Bool

congruence :: (Int -> Int) -> Int -> Int -> Bool
fx1 :: (Int -> Int) -> Int -> Bool

ex1, ex2 :: Bool -> Bool
ex3, ex3', ex4, ex6, ex7, exDeMorgan1, exDeMorgan2 :: Bool -> Bool -> Bool

infixr 9 ==>

{-@ invariant {v:[a] | size v >= 0} @-}

-- {-@ fail ex0' @-}
-- {-@ fail ex3' @-}
-- {-@ fail exDeMorgan2 @-}
-- {-@ fail ax0' @-}
-- {-@ fail ax6 @-}

</div>
</div>

</div>

<p>As we shall see shortly, a refinement type is:</p>
<blockquote>
<p><em>Refinement Types</em> = <em>Types</em> + <em>Logical
Predicates</em></p>
</blockquote>
<p>Let us begin by quickly recalling what we mean by “logical
predicates” in the remainder of this tutorial. <a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> To
this end, we will describe <em>syntax</em>, that is, what predicates
<em>look</em> like, and <em>semantics</em>, which is a fancy word for
what predicates <em>mean</em>.</p>
<section id="syntax" class="level2">
<h2>Syntax</h2>
<p>A <em>logical predicate</em> is, informally speaking, a Boolean
valued term drawn from a <em>restricted</em> subset of Haskell. In
particular, the expressions are drawn from the following grammar
comprising <em>constants</em>, <em>expressions</em> and
<em>predicates</em>.</p>
<p><br />
<strong>A Constant</strong><a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> <code>c</code> is simply
one of the numeric values:</p>
<pre class="spec"><code>    c := 0, 1, 2, ...</code></pre>
<p><br />
<strong>A Variable</strong> <code>v</code> is one of <code>x</code>,
<code>y</code>, <code>z</code>, etc., these will refer to (the values
of) binders in our source programs.</p>
<pre class="spec"><code>    v := x, y, z, ...</code></pre>
<p><br />
<strong>An Expression</strong> <code>e</code> is one of the following
forms; that is, an expression is built up as linear arithmetic
expressions over variables and constants and uninterpreted function
applications.</p>
<pre class="spec"><code>    e := v                      -- variable
       | c                      -- constant
       | (e + e)                -- addition
       | (e - e)                -- subtraction
       | (c * e)                -- multiplication by constant
       | (v e1 e2 ... en)       -- uninterpreted function application
       | (if p then e else e)   -- if-then-else</code></pre>
<p><br />
<strong>Examples of Expressions</strong> include the following:</p>
<ul>
<li><code>x + y - z</code></li>
<li><code>2 * x</code></li>
<li><code>1 + size x</code></li>
</ul>
<p><br />
<strong>A Relation</strong> is one of the usual (arithmetic) comparison
operators:</p>
<pre class="spec"><code>    r := ==               -- equality
       | /=               -- disequality
       | &gt;=               -- greater than or equal
       | &lt;=               -- less than or equal
       | &gt;                -- greater than
       | &lt;                -- less than</code></pre>
<p><br />
<strong>A Predicate</strong> is either an atomic predicate, obtained by
comparing two expressions, or, an application of a predicate function to
a list of arguments, or the Boolean combination of the above predicates
with the operators <code>&amp;&amp;</code> (and), <code>||</code> (or),
<code>==&gt;</code> (implies <a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a>), <code>&lt;=&gt;</code>
(if and only if <a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>), and <code>not</code>.</p>
<pre class="spec"><code>    p := (e r e)                -- binary relation
       | (v e1 e2 ... en)       -- predicate (or alias) application
       | (p &amp;&amp; p)               -- and
       | (p || p)               -- or
       | (p =&gt; p) | (p ==&gt; p)   -- implies
       | (p &lt;=&gt; p)              -- iff
       | (not p)                -- negation
       | true | True
       | false | False</code></pre>
<p><br />
<strong>Examples of Predicates</strong> include the following:</p>
<ul>
<li><code>x + y &lt;= 3</code></li>
<li><code>null x</code></li>
<li><code>x &lt; 10 ==&gt; y &lt; 10 ==&gt; x + y &lt; 20</code></li>
<li><code>0 &lt; x + y &lt;=&gt; 0 &lt; y + x</code></li>
</ul>
</section>
<section id="semantics" class="level2">
<h2>Semantics</h2>
<p>The syntax of predicates tells us what they <em>look</em> like, that
is, what we can <em>write down</em> as valid predicates. Next, let us
turn our attention to what a predicate <em>means</em>. Intuitively, a
predicate is just a Boolean valued Haskell function with
<code>&amp;&amp;</code>, <code>||</code>, <code>not</code> being the
usual operators and <code>==&gt;</code> and <code>&lt;=&gt;</code> being
two special operators.</p>
<p><br />
<strong>The Implication</strong> operator <code>==&gt;</code> is
equivalent to the following Haskell function. (For now, ignore the
signature: it just says the output is a <code>Bool</code> that is equal
to the <em>logical</em> implication between the inputs <code>p</code>
and <code>q</code>.)</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">{-@ (==>) :: p:Bool -> q:Bool -> {v:Bool | v <=> (p ==> q)} @-}
False ==> False = True
False ==> True  = True
True  ==> True  = True
True  ==> False = False</div>
</div>

<p><br />
<strong>The If-and-only-if</strong> operator <code>&lt;=&gt;</code> is
equivalent to the Haskell function:<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ (<=>) :: p:Bool -> q:Bool -> {v:Bool | v <=> (p <=> q)} @-}
False <=> False = True
False <=> True  = False
True  <=> True  = True
True  <=> False = False</div>
</div>

<p><br />
<strong>An Environment</strong> is a mapping from variables to their
Haskell types. For example, let <code>G</code> be an environment defined
as</p>
<pre class="spec"><code>    x :: Int
    y :: Int
    z :: Int</code></pre>
<p> which maps each variable <code>x</code>, <code>y</code> and
<code>z</code> to the type <code>Int</code>.</p>
<p><br />
<strong>An Assignment</strong> under an environment, is a mapping from
variables to values of the type specified in the environment. For
example,</p>
<pre class="spec"><code>    x := 1
    y := 2
    z := 3</code></pre>
<p> is an assignment under <code>G</code> that maps <code>x</code>,
<code>y</code> and <code>z</code> to the <code>Int</code> values
<code>1</code>, <code>2</code> and <code>3</code> respectively.</p>
<p><br />
<strong>A Predicate Evaluates</strong> to either <code>True</code> or
<code>False</code> under a given assignment. For example, the
predicate</p>
<pre class="spec"><code>    x + y &gt; 10</code></pre>
<p> evaluates to <code>False</code> given the above assignment but
evaluates to <code>True</code> under the assignment</p>
<pre class="spec"><code>    x := 10
    y := 10
    z := 20</code></pre>
<p><br />
<strong>A Predicate is Satisfiable</strong> in an environment if
<em>there exists</em> an assignment (in that environment) that makes the
predicate evaluate to <code>True</code>. For example, in <code>G</code>
the predicate</p>
<pre class="spec"><code>    x + y == z</code></pre>
<p> is satisfiable, as the above assignment makes the predicate evaluate
to <code>True</code>.</p>
<p><br />
<strong>A Predicate is Valid</strong> in an environment if
<em>every</em> assignment in that environment makes the predicate
evaluate to <code>True</code>. For example, the predicate</p>
<pre class="spec"><code>    x &lt; 10 || x == 10 || x &gt; 10</code></pre>
<p> is valid under <code>G</code> as no matter what value we assign to
<code>x</code>, the above predicate will evaluate to
<code>True</code>.</p>
</section>
<section id="verification-conditions" class="level2">
<h2>Verification Conditions</h2>
<p>LiquidHaskell works without actually <em>executing</em> your
programs. Instead, it checks that your program meets the given
specifications in roughly two steps.</p>
<ol type="1">
<li><p>First, LH combines the code and types down to a set of
<em>Verification Conditions</em> (VC) which are predicates that are
valid <em>only if</em> your program satisfies a given property. <a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a></p></li>
<li><p>Next, LH <em>queries</em> an <a
href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">SMT
solver</a> to determine whether these VCs are valid. If so, it says your
program is <em>safe</em> and otherwise it <em>rejects</em> your
program.</p></li>
</ol>
<p><br />
<strong>The SMT Solver decides</strong> whether a predicate (VC) is
valid <em>without enumerating</em> and evaluating all assignments.
Indeed, it is impossible to do so as there are usually infinitely many
assignments once the predicates refer to integers or lists and so on.
Instead, the SMT solver uses a variety of sophisticated <em>symbolic
algorithms</em> to deduce whether a predicate is valid or not. This
process is the result of decades of work in mathematical logic and
decision procedures; the <a
href="https://people.eecs.berkeley.edu/~necula/Papers/nelson-thesis.pdf">Ph.D
thesis of Greg Nelson</a> is an excellent place to learn more about
these beautiful algorithms.</p>
<p><br />
<strong>We Restrict the Logic</strong> to ensure that all our VC queries
fall within the <em>decidable fragment</em>. This makes LiquidHaskell
extremely automatic – there is <em>no</em> explicit manipulation of
proofs, just the specification of properties via types and of course,
the implementation via Haskell code! This automation comes at a price:
all our refinements <em>must</em> belong to the logic above.
Fortunately, with a bit of creativity, we can say a <em>lot</em> in this
logic. <a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a></p>
</section>
<section id="examples-propositions" class="level2">
<h2>Examples: Propositions</h2>
<p>Finally, let’s conclude this quick overview with some examples of
predicates, in order to build up our own intuition about logic and
validity. Each of the below is a predicate from our refinement logic.
However, we write them as raw Haskell expressions that you may be more
familiar with right now, and so that we can start to use LiquidHaskell
to determine whether a predicate is indeed valid or not.</p>
<p><br />
<strong>Let `TRUE` be a refined type</strong> for <code>Bool</code>
valued expressions that <em>always</em> evaluate to <code>True</code>.
Similarly, we can define <code>FALSE</code> for <code>Bool</code> valued
expressions that <em>always</em> evaluate to <code>False</code>:<a
href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a></p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ type TRUE  = {v:Bool | v    } @-}
{-@ type FALSE = {v:Bool | not v} @-}</div>
</div>

<p> Thus, a <em>valid predicate</em> is one that has the type
<code>TRUE</code>. The simplest example of a valid predicate is just
<code>True</code>:</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">{-@ ex0 :: TRUE @-}
ex0 = True</div>
</div>

<p>of course, <code>False</code> is <em>not valid</em></p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">{-@ ex0' :: TRUE @-}
ex0' = False</div>
</div>

<p>We can get more interesting predicates if we use variables. For
example, the following is valid predicate says that a <code>Bool</code>
variable is either <code>True</code> or <code>False</code>.</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ ex1 :: Bool -> TRUE @-}
ex1 b = b || not b</div>
</div>

<p>Of course, a variable cannot be both <code>True</code> and
<code>False</code>, and so the below predicate is valid:</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ ex2 :: Bool -> FALSE @-}
ex2 b = b && not b</div>
</div>

<p>The next few examples illustrate the <code>==&gt;</code> operator.
You should read <code>p ==&gt; q</code> as <em>if</em> <code>p</code> is
true <em>then</em> <code>q</code> must also be true. Thus, the below
predicates are valid as if both <code>a</code> and <code>b</code> are
true, then well, <code>a</code> is true, and <code>b</code> is true.</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ ex3 :: Bool -> Bool -> TRUE @-}
ex3 a b = (a && b) ==> a

{-@ ex4 :: Bool -> Bool -> TRUE @-}
ex4 a b = (a && b) ==> b</div>
</div>

<div id="Implications and Or" class="hwex">
<p><br />
<strong>Exercise: (Implications and Or): </strong>Of course, if we
replace the <code>&amp;&amp;</code> with <code>||</code> the result is
<em>not valid</em>. Can you shuffle the variables around – <em>without
changing the operators</em> – to make the formula valid?</p>
<br />
<br />

</div>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">{-@ ex3' :: Bool -> Bool -> TRUE @-}
ex3' a b = (a || b) ==> a</div>
</div>

<p>The following predicates are valid because they encode <a
href="http://en.wikipedia.org/wiki/Modus_ponens">modus ponens</a>: if
you know that <code>a</code> implies <code>b</code> and you know that
<code>a</code> is true, then it must be the case that <code>b</code> is
also true:</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ ex6 :: Bool -> Bool -> TRUE @-}
ex6 a b = (a && (a ==> b)) ==> b

{-@ ex7 :: Bool -> Bool -> TRUE @-}
ex7 a b = a ==> (a ==> b) ==> b</div>
</div>

<p>Recall that <code>p &lt;=&gt; q</code> (read <code>p</code> if and
only if <code>q</code>) evaluates to <code>True</code> exactly when
<code>p</code> and <code>q</code> evaluate to the <em>same</em> values
(<code>True</code> or <code>False</code>). It is used to encode
<em>equalities</em> between predicates. For example, we can write down
<a href="http://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s
laws</a> as the valid predicates:</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">{-@ exDeMorgan1 :: Bool -> Bool -> TRUE @-}
exDeMorgan1 a b = not (a || b) <=> (not a && not b)</div>
</div>

<div id="DeMorgan&#39;s Law" class="hwex">
<p><br />
<strong>Exercise: (DeMorgan's Law): </strong>The following version of
DeMorgan’s law is wrong. Can you fix it to get a valid formula?</p>
<br />
<br />

</div>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">{-@ exDeMorgan2 :: Bool -> Bool -> TRUE @-}
exDeMorgan2 a b = not (a && b) <=> (not a && not b)</div>
</div>

</section>
<section id="examples-arithmetic" class="level2">
<h2>Examples: Arithmetic</h2>
<p>Next, let’s look at some predicates involving arithmetic. The
simplest ones don’t have any variables, for example:</p>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">{-@ ax0 :: TRUE @-}
ax0 = 1 + 1 == 2</div>
</div>

<p>Again, a predicate that evaluates to <code>False</code> is
<em>not</em> valid:</p>
<div id="program-pane-14" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-14" class="programbox">{-@ ax0' :: TRUE @-}
ax0' = 1 + 1 == 3</div>
</div>

<p><br />
<strong>SMT Solvers determine Validity</strong> <em>without</em>
enumerating assignments. For example, consider the predicate:</p>
<div id="program-pane-15" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-15" class="programbox">{-@ ax1 :: Int -> TRUE @-}
ax1 x = x < x + 1</div>
</div>

<p>It is trivially valid; as via the usual laws of arithmetic, it is
equivalent to <code>0 &lt; 1</code> which is <code>True</code>
independent of the value of <code>x</code>. The SMT solver is able to
determine this validity without enumerating the infinitely many possible
values for <code>x</code>. This kind of validity checking lies at the
heart of LiquidHaskell.</p>
<p>operators, as shown in the following examples:</p>
<div id="program-pane-16" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-16" class="programbox">{-@ ax2 :: Int -> TRUE @-}
ax2 x = (x < 0) ==> (0 <= 0 - x)

{-@ ax3 :: Int -> Int -> TRUE @-}
ax3 x y = (0 <= x) ==> (0 <= y) ==> (0 <= x + y)

{-@ ax4 :: Int -> Int -> TRUE @-}
ax4 x y = (x == y - 1) ==> (x + 2 == y + 1)

{-@ ax5 :: Int -> Int -> Int -> TRUE @-}
ax5 x y z =   (x <= 0 && x >= 0)
          ==> (y == x + z)
          ==> (y == z)</div>
</div>

<div id="Addition and Order" class="hwex">
<p><br />
<strong>Exercise: (Addition and Order): </strong>The formula below is
<em>not</em> valid. Do you know why? Change the <em>hypothesis</em>
i.e. the thing to the left of the <code>==&gt;</code> to make it a valid
formula.</p>
<br />
<br />

</div>
<div id="program-pane-17" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-17" class="programbox">{-@ ax6 :: Int -> Int -> TRUE @-}
ax6 x y = True ==> (x <= x + y)</div>
</div>

</section>
<section id="examples-uninterpreted-function" class="level2">
<h2>Examples: Uninterpreted Function</h2>
<p>We say that function symbols are <em>uninterpreted</em> in the
refinement logic, because the SMT solver does not “know” how functions
are defined. Instead, the only thing that the solver knows is the
<em>axiom of congruence</em> which states that any function
<code>f</code>, returns equal outputs when invoked on equal inputs.</p>
<p><br />
<strong>We Test the Axiom of Congruence</strong> by checking that the
following predicate is valid:</p>
<div id="program-pane-18" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-18" class="programbox">{-@ congruence :: (Int -> Int) -> Int -> Int -> TRUE @-}
congruence f x y = (x == y) ==> (f x == f y)</div>
</div>

<p>Again, remember we are <em>not evaluating</em> the code above; indeed
we <em>cannot</em> evaluate the code above because we have no definition
of <code>f</code>. Still, the predicate is valid as the congruence axiom
holds for any possible interpretation of <code>f</code>.</p>
<p>Here is a fun example; can you figure out why this predicate is
indeed valid? (The SMT solver can…)</p>
<div id="program-pane-19" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-19" class="programbox">{-@ fx1 :: (Int -> Int) -> Int -> TRUE @-}
fx1 f x =   (x == f (f (f x)))
        ==> (x == f (f (f (f (f x)))))
        ==> (x == f x)</div>
</div>

<p>To get a taste of why uninterpreted functions will prove useful,
let’s write a function to compute the <code>size</code> of a list:</p>
<div id="program-pane-20" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-20" class="programbox">{-@ measure size @-}
{-@ size :: [a] -> Nat @-}
size        :: [a] -> Int
size []     = 0
size (x:xs) = 1 + size xs</div>
</div>

<p>We can now verify that the following predicates are
<em>valid</em>:</p>
<div id="program-pane-21" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-21" class="programbox">{-@ fx0 :: [a] -> [a] -> TRUE @-}
fx0 xs ys = (xs == ys) ==> (size xs == size ys)</div>
</div>

<p>Note that to determine that the above is valid, the SMT solver does
not need to know the <em>meaning</em> or <em>interpretation</em> of
<code>size</code> – merely that it is a function. When we need some
information about the definition, of <code>size</code> we will put it
inside the predicate. For example, in order to prove that the following
is valid:</p>
<div id="program-pane-22" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-22" class="programbox">{-@ fx2 :: a -> [a] -> TRUE @-}
fx2 x xs = 0 < size ys
  where
    ys   = x : xs</div>
</div>

<p>LiquidHaskell actually asks the SMT solver to prove the validity of a
VC predicate which states that sizes are non-negative and that since
<code>ys</code> equals <code>x:xs</code>, the size of <code>ys</code> is
one more than <code>xs</code>. <a href="#fn9" class="footnote-ref"
id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<div id="program-pane-23" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-23" class="programbox">{-@ fx2VC :: _ -> _ -> _ -> TRUE @-}
fx2VC x xs ys =   (0 <= size xs)
              ==> (size ys == 1 + size xs)
              ==> (0 < size ys)</div>
</div>

</section>
<section id="recap" class="level2">
<h2>Recap</h2>
<p>This chapter describes exactly what we, for the purposes of this
book, mean by the term <em>logical predicate</em>.</p>
<ol type="1">
<li>We defined a grammar – a restricted subset of Haskell corresponding
to <code>Bool</code> valued expressions.</li>
<li>The restricted grammar lets us use SMT solvers to decide whether a
predicate is <em>valid</em> that is, evaluates to <code>True</code> for
<em>all</em> values of the variables.</li>
<li>Crucially, the SMT solver determines validity <em>without
enumerating</em> and evaluating the predicates (which would take
forever!) but instead by using clever symbolic algorithms.</li>
</ol>
<p>Next, let’s see how we can use logical predicates to <em>specify</em>
and <em>verify</em> properties of real programs.</p>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If you are comfortable with this material, e.g. if you
know what the “S”, “M” and “T” stand for in SMT, and what QF-UFLIA
stands for (i.e. the quantifier free theory of linear arithmetic and
uninterpreted functions), then feel free skip to the next chapter.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>When you see := you should read it as “is defined to
be”<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Read <code>p ==&gt; q</code> as “if <code>p</code> then
<code>q</code>”<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Read <code>p &lt;=&gt; q</code> as “if <code>p</code>
then <code>q</code> <strong>and</strong> if <code>q</code> then
<code>p</code>”<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>An observant reader may notice that &lt;=&gt; is the
same as == if the arguments are of type Bool<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>The process is described at length in <a
href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types.pdf">this
paper</a><a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>In particular, we will use the uninterpreted functions
to create many sophisticated abstractions.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>This syntax will be discussed in greater detail <a
href="#propositions">soon</a><a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Fear not! We will describe how this works <a
href="#autosmart">soon</a><a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquid-demo.programming.systems/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
