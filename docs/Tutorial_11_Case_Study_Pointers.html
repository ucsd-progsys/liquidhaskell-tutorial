<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Programming with Refinement Types</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Tutorial_01_Introduction.html'><b>1.</b>Introduction {#intro}</a></li>
<ul class='section'>
<li><a href='Tutorial_01_Introduction.html#'><b>1.1.</b> Well-Typed Programs Do Go Wrong {#gowrong}</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.2.</b> Refinement Types</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.3.</b> Audience</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.4.</b> Getting Started</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.5.</b> Sample Code</a></li>
</ul>
<li><a href='Tutorial_02_Logic.html'><b>2.</b>Logic &amp; SMT</a></li>
<ul class='section'>
<li><a href='Tutorial_02_Logic.html#'><b>2.1.</b> Syntax</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.2.</b> Semantics {#semantics}</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.3.</b> Verification Conditions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.4.</b> Examples: Propositions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.5.</b> Examples: Arithmetic</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.6.</b> Examples: Uninterpreted Function</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_03_Basic.html'><b>3.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Tutorial_03_Basic.html#'><b>3.1.</b> Defining Types {#definetype}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.2.</b> Errors</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.3.</b> Subtyping</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.4.</b> Writing Specifications</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.5.</b> Refining Function Types: Pre-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.6.</b> Refining Function Types: Post-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.7.</b> Testing Values: Booleans and Propositions {#propositions}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.8.</b> Putting It All Together</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.9.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_04_Polymorphism.html'><b>4.</b>Polymorphism {#polymorphism}</a></li>
<ul class='section'>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.1.</b> Specification: Vector Bounds {#vectorbounds}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.2.</b> Verification: Vector Lookup</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.3.</b> Inference: Our First Recursive Function</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.4.</b> Higher-Order Functions: Bottling Recursion in a <code>loop</code></a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.5.</b> Refinements and Polymorphism {#sparsetype}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.6.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_05_Datatypes.html'><b>5.</b>Refined Datatypes {#refineddatatypes}</a></li>
<ul class='section'>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.1.</b> Sparse Vectors Revisited {#autosmart}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.2.</b> Ordered Lists {#orderedlists}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.3.</b> Ordered Trees {#binarysearchtree}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_06_Measure_Bool.html'><b>6.</b>Boolean Measures {#boolmeasures}</a></li>
<ul class='section'>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.1.</b> Partial Functions</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.2.</b> Lifting Functions to Measures {#usingmeasures}</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.3.</b> A Safe List API</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_07_Measure_Int.html'><b>7.</b>Numeric Measures {#numericmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.1.</b> Wholemeal Programming</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.2.</b> Specifying List Dimensions</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.3.</b> Lists: Size Preserving API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.4.</b> Lists: Size Reducing API {#listreducing}</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.5.</b> Dimension Safe Vector API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.6.</b> Dimension Safe Matrix API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_08_Measure_Set.html'><b>8.</b>Elemental Measures {#setmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.1.</b> Talking about Sets</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.2.</b> Proving QuickCheck Style Properties {#quickcheck}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.3.</b> Content-Aware List API {#listelems}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.4.</b> Permutations</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.5.</b> Uniqueness</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.6.</b> Unique Zippers</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html'><b>9.</b>Case Study: Okasaki's Lazy Queues {#lazyqueue}</a></li>
<ul class='section'>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.1.</b> Queues</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.2.</b> Sized Lists</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.3.</b> Queue Type</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.4.</b> Queue Operations</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.5.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html'><b>10.</b>Case Study: Associative Maps</a></li>
<ul class='section'>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.1.</b> Specifying Maps {#mapapi}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.2.</b> Using Maps: Well Scoped Expressions</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.3.</b> Implementing Maps: Binary Search Trees {#lemmas}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_11_Case_Study_Pointers.html'><b>11.</b>Case Study: Pointers &amp; Bytes {#case-study-pointers}</a></li>
<ul class='section'>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.1.</b> HeartBleeds in Haskell</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.2.</b> Low-level Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.3.</b> A Refined Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.4.</b> Assumptions vs Guarantees</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.5.</b> ByteString API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.6.</b> Application API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.7.</b> Nested ByteStrings</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.8.</b> Recap: Types Against Overflows</a></li>
</ul>
<li><a href='Tutorial_12_Case_Study_AVL.html'><b>12.</b>Case Study: AVL Trees {#case-study-avltree}</a></li>
<ul class='section'>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.1.</b> AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.2.</b> Specifying AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.3.</b> Smart Constructors</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.4.</b> Inserting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.5.</b> Rebalancing Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.6.</b> Refactoring Rebalance</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.7.</b> Deleting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.8.</b> Functional Correctness</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="case-study-pointers" class="level1">
<h1>Case Study: Pointers &amp; Bytes</h1>
<div class="hidden">
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{-@ LIQUID "--no-termination" @-}
{-@ LIQUID "--short-names"    @-}
{-@ LIQUID "--prune"          @-}

{-# LANGUAGE ForeignFunctionInterface #-}

module Tutorial_11_Case_Study_Pointers where

import Prelude hiding (null)

import Data.Word
import Foreign.C.Types
import Foreign.ForeignPtr
import Foreign.Ptr
import Foreign.Storable
import System.IO.Unsafe
import Data.ByteString.Internal (c2w, w2c)
-- import Language.Haskell.Liquid.Prelude

spanByte         :: Word8 -> ByteString -> (ByteString, ByteString)
unsafeHead       :: ByteString -> Word8
create, create'  :: Int -> (Ptr Word8 -> IO ()) -> ByteString

-- boilerplate
{-@ type TRUE = {v:Bool | v } @-}

-- TODO: we really shouldn't need this...
-- {- bLen :: b:ByteString -> {v:Nat | v = bLen b} @-}

{-@ type StringN N = {v:String | len v = N} @-}
{-@ type BNat N    = {v:Nat    | v <= N}    @-}

{- ignore spanByte @-}
-- {-@ ignore chop' @-}
-- {-@ fail zero4' @-}
-- {-@ fail exBad @-}
-- {-@ fail bad1 @-}
-- {-@ fail bad2 @-}
-- {-@ fail bsGHC @-}
-- {-@ fail prop_pack_length @-}
-- {-@ fail prop_unpack_length @-}
-- {-@ fail prop_chop_length @-}
-- {-@ fail demo @-}
-- {-@ ignore pLoop @-}
-- {-@ ignore safeChop @-}
-- {-@ ignore unsafeTake @-}
-- {-@ ignore unsafeDrop @-}


</div>
</div>

</div>

<p>A large part of the allure of Haskell is its elegant, high-level ADTs
that ensure that programs won’t be plagued by problems like the infamous
<a href="heartbleed.com">SSL heartbleed bug</a>.<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
However, another part of Haskell’s charm is that when you really really
need to, you can drop down to low-level pointer twiddling to squeeze the
most performance out of your machine. But of course, that opens the door
to the heartbleeds.</p>
<p>Wouldn’t it be nice to have our cake and eat it too? Wouldn’t it be
great if we could twiddle pointers at a low-level and still get the nice
safety assurances of high-level types? Lets see how LiquidHaskell lets
us have our cake and eat it too.</p>
<section id="heartbleeds-in-haskell" class="level2">
<h2>HeartBleeds in Haskell</h2>
<p><br />
<strong>Modern Languages</strong> like Haskell are ultimately built upon
the foundation of <code>C</code>. Thus, implementation errors could open
up unpleasant vulnerabilities that could easily slither past the type
system and even code inspection. As a concrete example, lets look at a
function that uses the <code>ByteString</code> library to truncate
strings:</p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">chop'     :: String -> Int -> String
chop' s n = s'
  where
    b     = pack s          -- down to low-level
    b'    = unsafeTake n b  -- grab n chars
    s'    = unpack b'       -- up to high-level</div>
</div>

<p>First, the function <code>pack</code>s the string into a low-level
bytestring <code>b</code>, then it grabs the first <code>n</code>
<code>Char</code>acters from <code>b</code> and translates them back
into a high-level <code>String</code>. Lets see how the function works
on a small test:</p>
<pre class="spec"><code>ghci&gt; let ex = &quot;Ranjit Loves Burritos&quot;</code></pre>
<p>We get the right result when we <code>chop</code> a <em>valid</em>
prefix:</p>
<pre class="spec"><code>ghci&gt; chop&#39; ex 10
&quot;Ranjit Lov&quot;</code></pre>
<p>But, as illustrated in Figure <a href="#fig:overflow">1.1</a>, the
machine silently reveals (or more colorfully, <em>bleeds</em>) the
contents of adjacent memory or if we use an <em>invalid</em> prefix:</p>
<pre class="spec"><code>ghci&gt; chop&#39; ex 30
&quot;Ranjit Loves Burritos\NUL\201\&amp;1j\DC3\SOH\NUL&quot;</code></pre>
<div id="fig:overflow" style="align: left; text-align:center;">
  <img src="img/overflow.png" height="100px" style="display:block;  margin-left:auto; margin-right:auto">
  <div class="caption" style="text-align:center"><b>Figure 1.1:</b> Can we prevent the program from leaking secrets via overflows? </div>
</div>
<br>


<p><br />
<strong>Types against Overflows</strong> Now that we have stared the
problem straight in the eye, look at how we can use LiquidHaskell to
prevent the above at compile time. To this end, we decompose the system
into a hierarchy of levels (i.e. modules). Here, we have three
levels:</p>
<ol type="1">
<li><em>Machine</em> level <code>Pointers</code></li>
<li><em>Library</em> level <code>ByteString</code></li>
<li><em>User</em> level <code>Application</code></li>
</ol>
<p>Our strategy, as before, is to develop an <em>refined API</em> for
each level such that errors at each level are prevented by using the
typed interfaces for the lower levels. Next, lets see how this strategy
lets us safely manipulate pointers.</p>
</section>
<section id="low-level-pointer-api" class="level2">
<h2>Low-level Pointer API</h2>
<p>To get started, lets look at the low-level pointer API that is
offered by GHC and the run-time. First, lets see who the <em>dramatis
personae</em> are and how they might let heartbleeds in. Then we will
see how to batten down the hatches with LiquidHaskell.</p>
<p><br />
<strong>Pointers</strong> are an (abstract) type <code>Ptr a</code>
implemented by GHC.</p>
<pre class="spec"><code>-- | A value of type `Ptr a` represents a pointer to an object,
--   or an array of objects, which may be marshalled to or from
--   Haskell values of type `a`.

data Ptr a</code></pre>
<p><br />
<strong>Foreign Pointers</strong> are <em>wrapped</em> pointers that can
be exported to and from C code via the <a
href="http://hackage.haskell.org/package/base/docs/Foreign-Ptr.html">Foreign
Function Interface</a>.</p>
<pre class="spec"><code>data ForeignPtr a</code></pre>
<p><br />
<strong>To Create</strong> a pointer we use
<code>mallocForeignPtrBytes n</code> which creates a <code>Ptr</code> to
a buffer of size <code>n</code> and wraps it as a
<code>ForeignPtr</code></p>
<pre class="spec"><code>mallocForeignPtrBytes :: Int -&gt; ForeignPtr a</code></pre>
<p><br />
<strong>To Unwrap</strong> and actually use the <code>ForeignPtr</code>
we use</p>
<pre class="spec"><code>withForeignPtr :: ForeignPtr a     -- pointer
               -&gt; (Ptr a -&gt; IO b)  -- action
               -&gt; IO b             -- result</code></pre>
<p>That is, <code>withForeignPtr fp act</code> lets us execute a action
<code>act</code> on the actual <code>Ptr</code> wrapped within the
<code>fp</code>. These actions are typically sequences of
<em>dereferences</em>, i.e. reads or writes.</p>
<p><br />
<strong>To Dereference</strong> a pointer, i.e. to read or update the
contents at the corresponding memory location, we use <code>peek</code>
and <code>poke</code> respectively. <a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<pre class="spec"><code>peek :: Ptr a -&gt; IO a         -- Read
poke :: Ptr a -&gt; a -&gt; IO ()   -- Write</code></pre>
<p><br />
<strong>For Fine Grained Access</strong> we can directly shift pointers
to arbitrary offsets using the <em>pointer arithmetic</em> operation
<code>plusPtr p off</code> which takes a pointer <code>p</code> an
integer <code>off</code> and returns the address obtained shifting
<code>p</code> by <code>off</code>:</p>
<pre class="spec"><code>plusPtr :: Ptr a -&gt; Int -&gt; Ptr b</code></pre>
<p><br />
<strong>Example</strong> That was rather dry; lets look at a concrete
example of how one might use the low-level API. The following function
allocates a block of 4 bytes and fills it with zeros:</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">zero4 = do fp <- mallocForeignPtrBytes 4
           withForeignPtr fp $ \p -> do
             poke (p `plusPtr` 0) zero
             poke (p `plusPtr` 1) zero
             poke (p `plusPtr` 2) zero
             poke (p `plusPtr` 3) zero
           return fp
        where
           zero = 0 :: Word8</div>
</div>

<p>While the above is perfectly all right, a small typo could easily
slip past the type system (and run-time!) leading to hard to find
errors:</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">zero4' = do fp <- mallocForeignPtrBytes 4
            withForeignPtr fp $ \p -> do
              poke (p `plusPtr` 0) zero
              poke (p `plusPtr` 1) zero
              poke (p `plusPtr` 2) zero
              poke (p `plusPtr` 8) zero
            return fp
         where
            zero = 0 :: Word8</div>
</div>

</section>
<section id="a-refined-pointer-api" class="level2">
<h2>A Refined Pointer API</h2>
<p>Wouldn’t it be great if we had an assistant to helpfully point out
the error above as soon as we <em>wrote</em> it? <a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> We
will use the following strategy to turn LiquidHaskell into such an
assistant:</p>
<ol type="1">
<li><em>Refine</em> pointers with allocated buffer size,</li>
<li><em>Track</em> sizes in pointer operations,</li>
<li><em>Enforce</em> pointer are valid at reads and writes.</li>
</ol>
<p><br />
<strong>To Refine Pointers</strong> with the <em>size</em> of their
associated buffers, we can use an <em>abstract measure</em>, i.e. a
measure specification <em>without</em> any underlying
implementation.</p>
<pre class="spec"><code>-- | Size of `Ptr`
measure plen  :: Ptr a -&gt; Int

-- | Size of `ForeignPtr`
measure fplen :: ForeignPtr a -&gt; Int</code></pre>
<p>It is helpful to define aliases for pointers of a given size
<code>N</code>:</p>
<pre class="spec"><code>type PtrN a N        = {v:Ptr a        | plen v  = N}
type ForeignPtrN a N = {v:ForeignPtr a | fplen v = N}</code></pre>
<p><br />
<strong>Abstract Measures</strong> are extremely useful when we don’t
have a concrete implementation of the underlying value, but we know that
the value <em>exists</em>. Here, we don’t have the value – inside
Haskell – because the buffers are manipulated within C. However, this is
no cause for alarm as we will simply use measures to refine the API, not
to perform any computations. <a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p><br />
<strong>To Refine Allocation</strong> we stipulate that the size
parameter be non-negative, and that the returned pointer indeed refers
to a buffer with exactly <code>n</code> bytes:</p>
<pre class="spec"><code>mallocForeignPtrBytes :: n:Nat -&gt; ForeignPtrN a n</code></pre>
<p><br />
<strong>To Refine Unwrapping</strong> we specify that the
<em>action</em> gets as input, an unwrapped <code>Ptr</code> whose size
<em>equals</em> that of the given <code>ForeignPtr</code>.</p>
<pre class="spec"><code>withForeignPtr :: fp:ForeignPtr a
               -&gt; (PtrN a (fplen fp) -&gt; IO b)
               -&gt; IO b</code></pre>
<p>This is a rather interesting <em>higher-order</em> specification.
Consider a call <code>withForeignPtr fp act</code>. If the
<code>act</code> requires a <code>Ptr</code> whose size <em>exceeds</em>
that of <code>fp</code> then LiquidHaskell will flag a (subtyping) error
indicating the overflow. If instead the <code>act</code> requires a
buffer of size less than <code>fp</code> then it is always safe to run
the <code>act</code> on a larger buffer. For example, the below variant
of <code>zero4</code> where we only set the first three bytes is fine as
the <code>act</code>, namely the function <code>\p -&gt; ...</code>, can
be typed with the requirement that the buffer <code>p</code> has size
<code>4</code>, even though only <code>3</code> bytes are actually
touched.</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">zero3 = do fp <- mallocForeignPtrBytes 4
           withForeignPtr fp $ \p -> do
             poke (p `plusPtr` 0) zero
             poke (p `plusPtr` 1) zero
             poke (p `plusPtr` 2) zero
           return fp
        where
           zero = 0 :: Word8</div>
</div>

<p><br />
<strong>To Refine Reads and Writes</strong> we specify that they can
only be done if the pointer refers to a non-empty (remaining) buffer.
That is, we define an alias:</p>
<pre class="spec"><code>type OkPtr a = {v:Ptr a | 0 &lt; plen v}</code></pre>
<p>that describes pointers referring to <em>non-empty</em> buffers (of
strictly positive <code>plen</code>), and then use the alias to
refine:</p>
<pre class="spec"><code>peek :: OkPtr a -&gt; IO a
poke :: OkPtr a -&gt; a -&gt; IO ()</code></pre>
<p>In essence the above type says that no matter how arithmetic was used
to shift pointers around, when the actual dereference happens, the size
<em>remaining</em> after the pointer must be non-negative, so that a
byte can be safely read from or written to the underlying buffer.</p>
<p><br />
<strong>To Refine the Shift</strong> operations, we simply check that
the pointer <em>remains</em> within the bounds of the buffer, and update
the <code>plen</code> to reflect the size remaining after the shift: <a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a></p>
<pre class="spec"><code>plusPtr :: p:Ptr a -&gt; off:BNat (plen p) -&gt; PtrN b (plen p - off)</code></pre>
<p>using the alias <code>BNat</code>, defined as:</p>
<pre class="spec"><code>type BNat N = {v:Nat | v &lt;= N}</code></pre>
<p><a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a></p>
<p><br />
<strong>Types Prevent Overflows</strong> Lets revisit the zero-fill
example from above to understand how the refinements help detect the
error:</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">exBad = do fp <- mallocForeignPtrBytes 4
           withForeignPtr fp $ \p -> do
             poke (p `plusPtr` 0) zero
             poke (p `plusPtr` 1) zero
             poke (p `plusPtr` 2) zero
             poke (p `plusPtr` 5) zero     -- LH complains
           return fp
        where
           zero = 0 :: Word8</div>
</div>

<p>Lets read the tea leaves to understand the above error:</p>
<pre class="liquiderror"><code>  Error: Liquid Type Mismatch
   Inferred type
     VV : {VV : Int | VV == ?a &amp;&amp; VV == 5}

   not a subtype of Required type
     VV : {VV : Int | VV &lt;= plen p}

   in Context
     zero : {zero : Word8 | zero == ?b}
     VV   : {VV : Int | VV == ?a &amp;&amp; VV == (5  :  int)}
     fp   : {fp : ForeignPtr a | fplen fp == ?c &amp;&amp; 0 &lt;= fplen fp}
     p    : {p  : Ptr a | fplen fp == plen p &amp;&amp; ?c &lt;= plen p &amp;&amp; ?b &lt;= plen p &amp;&amp; zero &lt;= plen p}
     ?a   : {?a : Int | ?a == 5}
     ?c   : {?c : Int | ?c == 4}
     ?b   : {?b : Integer | ?b == 0}</code></pre>
<p>The error says we’re bumping <code>p</code> up by
<code>VV == 5</code> using <code>plusPtr</code> but the latter
<em>requires</em> that bump-offset be within the size of the buffer
referred to by <code>p</code>, i.e. <code>VV &lt;= plen p</code>.
Indeed, in this context, we have:</p>
<pre class="liquiderror"><code>     p    : {p : Ptr a | fplen fp == plen p &amp;&amp; ?c &lt;= plen p &amp;&amp; ?b &lt;= plen p &amp;&amp; zero &lt;= plen p}
     fp   : {fp : ForeignPtr a | fplen fp == ?c &amp;&amp; 0 &lt;= fplen fp}</code></pre>
<p>that is, the size of <code>p</code>, namely <code>plen p</code>
equals the size of <code>fp</code>, namely <code>fplen fp</code> (thanks
to the <code>withForeignPtr</code> call). The latter equals to
<code>?c</code> which is <code>4</code> bytes. Thus, since the offset
<code>5</code> is not less than the buffer size <code>4</code>,
LiquidHaskell cannot prove that the call to <code>plusPtr</code> is
safe, hence the error.</p>
</section>
<section id="assumptions-vs-guarantees" class="level2">
<h2>Assumptions vs Guarantees</h2>
<p>At this point you ought to wonder: where is the code for
<code>peek</code>, <code>poke</code> or
<code>mallocForeignPtrBytes</code> and so on? How can we be sure that
the types we assigned to them are in fact legitimate?</p>
<p><br />
<strong>Frankly, we cannot</strong> as those functions are
<em>externally</em> implemented (in this case, in <code>C</code>), and
hence, invisible to the otherwise all-seeing eyes of LiquidHaskell.
Thus, we are <em>assuming</em> or <em>trusting</em> that those functions
behave according to their types. Put another way, the types for the
low-level API are our <em>specification</em> for what low-level pointer
safety. We shall now <em>guarantee</em> that the higher level modules
that build upon this API in fact use the low-level function in a manner
consistent with this specification.</p>
<p><br />
<strong>Assumptions are a Feature</strong> and not a bug, as they let us
to verify systems that use some modules for which we do not have the
code. Here, we can <em>assume</em> a boundary specification, and then
<em>guarantee</em> that the rest of the system is safe with respect to
that specification. <a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a></p>
</section>
<section id="bytestring-api" class="level2">
<h2>ByteString API</h2>
<p>Next, lets see how the low-level API can be used to implement to
implement <a
href="https://hackage.haskell.org/package/bytestring">ByteStrings</a>,
in a way that lets us perform fast string operations without opening the
door to overflows.</p>
<p><br />
<strong>A ByteString</strong> is implemented as a record of three
fields:</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">data ByteString = BS {
    bPtr :: ForeignPtr Word8
  , bOff :: !Int
  , bLen :: !Int
  }</div>
</div>

<ul>
<li><code>bPtr</code> is a <em>pointer</em> to a block of memory,</li>
<li><code>bOff</code> is the <em>offset</em> in the block where the
string begins,</li>
<li><code>bLen</code> is the number of bytes from the offset that belong
to the string.</li>
</ul>
<p>These entities are illustrated in Figure <a
href="#fig:bytestring">1.2</a>; the green portion represents the actual
contents of a particular <code>ByteString</code>. This representation
makes it possible to implement various operations like computing
prefixes and suffixes extremely quickly, simply by pointer
arithmetic.</p>
<div id="fig:bytestring" style="align: left; text-align:center;">
  <img src="img/bytestring.png" height="100px" style="display:block;  margin-left:auto; margin-right:auto">
  <div class="caption" style="text-align:center"><b>Figure 1.2:</b> Representing ByteStrings in memory. </div>
</div>
<br>


<p><br />
<strong>In a Legal ByteString</strong> the <em>start</em>
(<code>bOff</code>) and <em>end</em> (<code>bOff + bLen</code>) offsets
lie inside the buffer referred to by the pointer <code>bPtr</code>. We
can formalize this invariant with a data definition that will then make
it impossible to create illegal <code>ByteString</code>s:</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ data ByteString = BS {
      bPtr :: ForeignPtr Word8
    , bOff :: {v:Nat| v        <= fplen bPtr}
    , bLen :: {v:Nat| v + bOff <= fplen bPtr}
    }
  @-}</div>
</div>

<p>The refinements on <code>bOff</code> and <code>bLen</code> correspond
exactly to the legality requirements that the start and end of the
<code>ByteString</code> be <em>within</em> the block of memory referred
to by <code>bPtr</code>.</p>
<p><br />
<strong>For brevity</strong> lets define an alias for
<code>ByteString</code>s of a given size:</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ type ByteStringN N = {v:ByteString | bLen v = N} @-}</div>
</div>

<p><br />
<strong>Legal Bytestrings</strong> can be created by directly using the
constructor, as long as we pass in suitable offsets and lengths. For
example,</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">{-@ good1 :: IO (ByteStringN 5) @-}
good1 = do fp <- mallocForeignPtrBytes 5
           return (BS fp 0 5)</div>
</div>

<p>creates a valid <code>ByteString</code> of size <code>5</code>;
however we need not start at the beginning of the block, or use up all
the buffer, and can instead create <code>ByteString</code>s whose length
is less than the size of the allocated block, as shown in
<code>good2</code> whose length is <code>2</code> while the allocated
block has size <code>5</code>.</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ good2 :: IO (ByteStringN 2) @-}
good2 = do fp <- mallocForeignPtrBytes 5
           return (BS fp 3 2)</div>
</div>

<p><br />
<strong>Illegal Bytestrings</strong> are rejected by LiquidHaskell. For
example, <code>bad1</code>’s length is exceeds its buffer size, and is
flagged as such:</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">bad1 = do fp <- mallocForeignPtrBytes 3
          return (BS fp 0 10)</div>
</div>

<p>Similarly, <code>bad2</code> does have <code>2</code> bytes but
<em>not</em> if we start at the offset of <code>2</code>:</p>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">bad2 = do fp <- mallocForeignPtrBytes 3
          return (BS fp 2 2)</div>
</div>

<div id="Legal ByteStrings" class="hwex">
<p><br />
<strong>Exercise: (Legal ByteStrings): </strong>Modify the definitions
of <code>bad1</code> and <code>bad2</code> so they are <em>accepted</em>
by LiquidHaskell.</p>
<br />
<br />

</div>
<div class="toolinfo">
<p><br />
<strong>Measures are generated from Fields</strong> in the datatype
definition. As GHC lets us use the fields as accessor functions, we can
<em>refine</em> the types of those functions to specify their behavior
to LiquidHaskell. For example, we can type the (automatically generated)
field-accessor function <code>bLen</code> so that it actually returns
the exact size of the <code>ByteString</code> argument.</p>
</div>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">{-@ bLen :: b:ByteString -> {v: Nat | v = bLen b} @-}</div>
</div>

<p><br />
<strong>To Safely Create</strong> a <code>ByteString</code> the
implementation defines a higher order <code>create</code> function, that
takes a size <code>n</code> and accepts a <code>fill</code> action, and
runs the action after allocating the pointer. After running the action,
the function tucks the pointer into and returns a
<code>ByteString</code> of size <code>n</code>.</p>
<div id="program-pane-14" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-14" class="programbox">{-@ create :: n:Nat -> (Ptr Word8 -> IO ()) -> ByteStringN n @-}
create n fill = unsafePerformIO $ do
  fp  <- mallocForeignPtrBytes n
  withForeignPtr fp fill
  return (BS fp 0 n)</div>
</div>

<div id="Create" class="hwex">
<p><br />
<strong>Exercise: (Create): </strong>Why does LiquidHaskell
<em>reject</em> the following function that creates a
<code>ByteString</code> corresponding to <code>"GHC"</code>?</p>
<br />
<br />

</div>
<div id="program-pane-15" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-15" class="programbox">bsGHC = create 3 $ \p -> do
  poke (p `plusPtr` 0) (c2w 'G')
  poke (p `plusPtr` 1) (c2w 'H')
  poke (p `plusPtr` 2) (c2w 'C')</div>
</div>

<p><strong>Hint: </strong>The function writes into 3 slots starting at
<code>p</code>. How big should <code>plen p</code> be to allow this?
What type does LiquidHaskell infer for <code>p</code> above? Does it
meet the requirement? Which part of the <em>specification</em> or
<em>implementation</em> needs to be modified so that the relevant
information about <code>p</code> becomes available within the
<code>do</code>-block above? Make sure you figure out the above before
proceeding.</p>
<p><br />
<strong>To Pack</strong> a <code>String</code> into a
<code>ByteString</code> we simply call <code>create</code> with the
appropriate fill action:<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a></p>
<div id="program-pane-16" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-16" class="programbox">pack str      = create' n $ \p -> go p xs
  where
  n           = length str
  xs          = map c2w str
  go p (x:xs) = poke p x >> go (plusPtr p 1) xs
  go _ []     = return  ()</div>
</div>

<div id="Pack" class="hwex">
<p><br />
<strong>Exercise: (Pack): </strong>We can compute the size of a
<code>ByteString</code> by using the function: Fix the specification for
<code>pack</code> so that (it still typechecks!) and furthermore, the
following <a href="#quickcheck">QuickCheck style property</a> is
proved.</p>
<br />
<br />

</div>
<div id="program-pane-17" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-17" class="programbox">{-@ prop_pack_length  :: String -> TRUE @-}
prop_pack_length xs   = bLen (pack xs) == length xs</div>
</div>

<p><strong>Hint: </strong>Look at the type of <code>length</code>, and
recall that <code>len</code> is a <a href="#numericmeasure">numeric
measure</a> denoting the size of a list.</p>
<p><br />
<strong>The magic of inference</strong> ensures that <code>pack</code>
just works. Notice there is a tricky little recursive loop
<code>go</code> that is used to recursively fill in the
<code>ByteString</code> and actually, it has a rather subtle type
signature that LiquidHaskell is able to automatically infer.</p>
<div id="Pack Invariant" class="hwex">
<p><br />
<strong>Exercise: (Pack Invariant): </strong>Still, we’re here to learn,
so can you <em>write down</em> the type signature for the
<code>pLoop</code> so that the below variant of <code>pack</code> is
accepted by LiquidHaskell (Do this <em>without</em> cheating by peeping
at the type inferred for <code>go</code> above!)</p>
<br />
<br />

</div>
<div id="program-pane-18" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-18" class="programbox">packEx str     = create' n $ \p -> pLoop p xs
  where
  n            = length str
  xs           = map c2w str

{-@ pLoop      :: (Storable a) => p:Ptr a -> xs:[a] -> IO () @-}
pLoop p (x:xs) = poke p x >> pLoop (plusPtr p 1) xs
pLoop _ []     = return ()</div>
</div>

<p><strong>Hint: </strong>Remember that <code>len xs</code> denotes the
size of the list <code>xs</code>.</p>
<div id="Unsafe Take and Drop" class="hwex">
<p><br />
<strong>Exercise: (Unsafe Take and Drop): </strong>The functions
<code>unsafeTake</code> and <code>unsafeDrop</code> respectively extract
the prefix and suffix of a <code>ByteString</code> from a given
position. They are really fast since we only have to change the offsets.
But why does LiquidHaskell reject them? Can you fix the specifications
so that they are accepted?</p>
<br />
<br />

</div>
<div id="program-pane-19" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-19" class="programbox">{-@ unsafeTake :: n:Nat -> b:_ -> ByteStringN n @-}
unsafeTake n (BS x s _) = BS x s n

{-@ unsafeDrop :: n:Nat -> b:_ -> ByteStringN {bLen b - n} @-}
unsafeDrop n (BS x s l) = BS x (s + n) (l - n)</div>
</div>

<p><strong>Hint: </strong>Under what conditions are the returned
<code>ByteString</code>s legal?</p>
<p><br />
<strong>To Unpack</strong> a <code>ByteString</code> into a plain old
<code>String</code>, we essentially run <code>pack</code> in reverse, by
walking over the pointer, and reading out the characters one by one till
we reach the end:</p>
<div id="program-pane-20" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-20" class="programbox">unpack              :: ByteString -> String
unpack (BS _  _ 0)  = []
unpack (BS ps s l)  = unsafePerformIO
                        $ withForeignPtr ps
                        $ \p -> go (p `plusPtr` s) (l - 1) []
  where
    {-@ go     :: p:_ -> n:_ -> acc:_ -> IO {v:_ | true } @-}
    go p 0 acc = peekAt p 0 >>= \e -> return (w2c e : acc)
    go p n acc = peekAt p n >>= \e -> go p (n-1) (w2c e : acc)
    peekAt p n = peek (p `plusPtr` n)</div>
</div>

<div id="Unpack" class="hwex">
<p><br />
<strong>Exercise: (Unpack): </strong>Fix the specification for
<code>unpack</code> so that the below QuickCheck style property is
proved by LiquidHaskell.</p>
<br />
<br />

</div>
<div id="program-pane-21" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-21" class="programbox">{-@ prop_unpack_length :: ByteString -> TRUE @-}
prop_unpack_length b   = bLen b == length (unpack b)</div>
</div>

<p><strong>Hint: </strong>You will also have to fix the specification of
the helper <code>go</code>. Can you determine the output refinement
should be (instead of just <code>true</code>?) How <em>big</em> is the
output list in terms of <code>p</code>, <code>n</code> and
<code>acc</code>.</p>
</section>
<section id="application-api" class="level2">
<h2>Application API</h2>
<p>Finally, lets revisit our potentially “bleeding” <code>chop</code>
function to see how the refined <code>ByteString</code> API can prevent
errors. We require that the prefix size <code>n</code> be less than the
size of the input string <code>s</code>:</p>
<div id="program-pane-22" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-22" class="programbox">{-@ chop :: s:String -> n:BNat (len s) -> String @-}
chop s n = s'
  where
    b    = pack s          -- down to low-level
    b'   = unsafeTake n b  -- grab n chars
    s'   = unpack b'       -- up to high-level</div>
</div>

<p><br />
<strong>Overflows are prevented</strong> by LiquidHaskell, as it rejects
calls to <code>chop</code> where the prefix size is too large which is
what led to the overflow that spilled the contents of memory after the
string (cf. Figure <a href="#fig:overflow">1.1</a>). In the code below,
the first use of <code>chop</code> which defines <code>ex6</code> is
accepted as <code>6 &lt;= len ex</code> but the second call is rejected
as <code>30 &gt; len ex</code>.</p>
<div id="program-pane-23" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-23" class="programbox">demo     = [ex6, ex30]
  where
    ex   = ['L','I','Q','U','I','D']
    ex6  = chop ex 6   -- accepted by LH
    ex30 = chop ex 30  -- rejected by LH</div>
</div>

<div class="hwex" id="Chop">
<p>Fix the specification for <code>chop</code> so that the following
property is proved:</p>
<div id="program-pane-24" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-24" class="programbox">{-@ prop_chop_length  :: String -> Nat -> TRUE @-}
prop_chop_length s n
  | n <= length s     = length (chop s n) == n
  | otherwise         = True</div>
</div>

<div id="Checked Chop" class="hwex">
<p><br />
<strong>Exercise: (Checked Chop): </strong>In the above, we know
statically that the string is longer than the prefix, but what if the
string and prefix are obtained <em>dynamically</em>, e.g. as inputs from
the user? Fill in the implementation of <code>ok</code> below to ensure
that <code>chop</code> is called safely with user specified values:</p>
<br />
<br />

</div>
<div id="program-pane-25" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-25" class="programbox">safeChop      :: String -> Int -> String
safeChop str n
  | ok        = chop str n
  | otherwise = ""
  where
    ok        = True

queryAndChop  :: IO String
queryAndChop  = do putStrLn "Give me a string:"
                   str  <-  getLine
                   putStrLn "Give me a number:"
                   ns   <-  getLine
                   let n =  read ns :: Int
                   return $ safeChop str n</div>
</div>

</section>
<section id="nested-bytestrings" class="level2">
<h2>Nested ByteStrings</h2>
<p>For a more in-depth example, let’s take a look at <code>group</code>,
which transforms strings like <code>"foobaaar"</code> into
<em>lists</em> of strings like <code>["f","oo", "b", "aaa", "r"]</code>.
The specification is that <code>group</code> should produce a</p>
<ol type="1">
<li>list of <em>non-empty</em> <code>ByteStrings</code>,</li>
<li>the <em>sum of</em> whose lengths equals that of the input
string.</li>
</ol>
<p><br />
<strong>Non-empty ByteStrings</strong> are those whose length is
non-zero:</p>
<div id="program-pane-26" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-26" class="programbox">{-@ predicate Null B  = bLen B == 0                   @-}
{-@ type ByteStringNE = {v:ByteString | not (Null v)} @-}</div>
</div>

<p>We can use these to enrich the API with a <code>null</code> check</p>
<div id="program-pane-27" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-27" class="programbox">{-@ null :: b:_ -> {v:Bool | v <=> Null b} @-}
null (BS _ _ l) = l == 0</div>
</div>

<p>This check is used to determine if it is safe to extract the head and
tail of the <code>ByteString</code>. we can use refinements to ensure
the safety of the operations and also track the sizes. <a href="#fn9"
class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<div id="program-pane-28" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-28" class="programbox">{-@ unsafeHead :: ByteStringNE -> Word8 @-}
unsafeHead (BS x s _) = unsafePerformIO $
                          withForeignPtr x $ \p ->
                            peekByteOff p s

{-@ unsafeTail :: b:ByteStringNE -> ByteStringN {bLen b -1} @-}
unsafeTail (BS ps s l) = BS ps (s + 1) (l - 1)</div>
</div>

<p><br />
<strong>The Group`</strong> function recursively calls
<code>spanByte</code> to carve off the next group, and then returns the
accumulated results:</p>
<div id="program-pane-29" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-29" class="programbox">{-@ group :: b:_ -> {v: [ByteStringNE] | bsLen v = bLen b} @-}
group xs
    | null xs   = []
    | otherwise = let  y        = unsafeHead xs
                       (ys, zs) = spanByte y (unsafeTail xs)
                  in (y `cons` ys) : group zs</div>
</div>

<p>The first requirement, that the groups be non-empty is captured by
the fact that the output is a <code>[ByteStringNE]</code>. The second
requirement, that the sum of the lengths is preserved, is expressed by a
writing a <a href="#numericmeasure">numeric measure</a>:</p>
<div id="program-pane-30" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-30" class="programbox">{-@ measure bsLen @-}
bsLen        :: [ByteString] -> Int
bsLen []     = 0
bsLen (b:bs) = bLen b + bsLen bs</div>
</div>

<p><br />
<strong>SpanByte</strong> does a lot of the heavy lifting. It uses
low-level pointer arithmetic to find the <em>first</em> position in the
<code>ByteString</code> that is different from the input character
<code>c</code> and then splits the <code>ByteString</code> into a pair
comprising the prefix and suffix at that point. (If you filled in the
relevant type signatures above, the below code should typecheck even
after you <em>delete</em> the <code>assume</code> from the
specification.)</p>
<div id="program-pane-31" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-31" class="programbox">{-@ assume spanByte :: Word8 -> b:ByteString -> ByteString2 b @-}
spanByte c ps@(BS x s ln)
  = unsafePerformIO
      $ withForeignPtr x $ \p ->
         go (p `plusPtr` s) 0
  where
    go p i
      | i >= ln   = return (ps, empty)
      | otherwise = do c' <- peekByteOff p i
                       if c /= c'
                         then return (splitAt i)
                         else go p (i+1)
    splitAt i     = (unsafeTake i ps, unsafeDrop i ps)</div>
</div>

<p>LiquidHaskell infers that <code>0 &lt;= i &lt;= l</code> and
therefore that all of the memory accesses are safe. Furthermore, due to
the precise specifications given to <code>unsafeTake</code> and
<code>unsafeDrop</code>, it is able to prove that the output pair’s
lengths add up to the size of the input <code>ByteString</code>.</p>
<div id="program-pane-32" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-32" class="programbox">{-@ type ByteString2 B
      = {v:_ | bLen (fst v) + bLen (snd v) = bLen B} @-}</div>
</div>

</section>
<section id="recap-types-against-overflows" class="level2">
<h2>Recap: Types Against Overflows</h2>
<p>In this chapter we saw a case study illustrating how measures and
refinements enable safe low-level pointer arithmetic in Haskell. The
take away messages are that we can:</p>
<ol type="1">
<li><em>compose</em> larger systems from layers of smaller ones,</li>
<li><em>refine</em> APIs for each layer, which can be used to</li>
<li><em>design and validate</em> the layers above.</li>
</ol>
<p>We saw this recipe in action by developing a low-level
<code>Pointer</code> API, using it to implement fast
<code>ByteString</code>s API, and then building some higher-level
functions on top of the <code>ByteStrings</code>.</p>
<p><br />
<strong>The Trusted Computing Base</strong> in this approach includes
exactly those layers for which the code is <em>not</em> available, for
example, because they are implemented outside the language and accessed
via the FFI as with <code>mallocForeignPtrBytes</code> and
<code>peek</code> and <code>poke</code>. In this case, we can make
progress by <em>assuming</em> the APIs hold for those layers and verify
the rest of the system with respect to that API. It is important to note
that in the entire case study, it is only the above FFI signatures that
are <em>trusted</em>; the rest are all verified by LiquidHaskell.</p>
<div class="hidden">
<div id="program-pane-33" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-33" class="programbox">-----------------------------------------------------------------------
-- Helper Code
-----------------------------------------------------------------------

{-@ unsafeCreate :: l:Nat -> (PtrN Word8 l -> IO ()) -> ByteStringN l @-}
unsafeCreate n f = create' n f -- unsafePerformIO $ create n f

{-@ qualif PLLen(v:a, p:b) : len v <= plen p @-}
{-@ qualif ForeignPtrN(v:ForeignPtr a, n:int): fplen v = n @-}
{-@ qualif FPLenPLen(v:Ptr a, fp:ForeignPtr a): fplen fp = plen v @-}
{-@ qualif PtrLen(v:Ptr a, xs:List b): plen v = len xs @-}
{-@ qualif PlenEq(v: Ptr a, x: int): x <= plen v @-}

{-@ cons :: Word8 -> b:ByteString -> {v:ByteStringNE | bLen v = bLen b + 1} @-}
cons :: Word8 -> ByteString -> ByteString
cons c (BS x s l) = unsafeCreate (l+1) $ \p -> withForeignPtr x $ \f -> do
        poke p c
        memcpy (p `plusPtr` 1) (f `plusPtr` s) (fromIntegral l)

{-@ empty :: {v:ByteString | bLen v = 0} @-}
empty :: ByteString
empty = BS nullForeignPtr 0 0

{-@ assume mallocForeignPtrBytes :: n:Nat -> IO (ForeignPtrN a n) @-}
{-@ type ForeignPtrN a N = {v:ForeignPtr a | fplen v = N} @-}
{-@ malloc :: n:Nat -> IO (ForeignPtrN a n) @-}
malloc = mallocForeignPtrBytes

{-@ assume
    c_memcpy :: dst:PtrV Word8
             -> src:PtrV Word8
             -> size:{CSize | size <= plen src && size <= plen dst}
             -> IO (Ptr Word8)
  @-}
foreign import ccall unsafe "string.h memcpy" c_memcpy
    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO (Ptr Word8)

{-@ memcpy :: dst:PtrV Word8
           -> src:PtrV Word8
           -> size:{CSize | size <= plen src && size <= plen dst}
           -> IO ()
  @-}
memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
memcpy p q s = c_memcpy p q s >> return ()

{-@ assume nullForeignPtr :: {v: ForeignPtr Word8 | fplen v = 0} @-}
nullForeignPtr :: ForeignPtr Word8
nullForeignPtr = unsafePerformIO $ newForeignPtr_ nullPtr
{-# NOINLINE nullForeignPtr #-}

{-@ create' :: n:Nat -> (PtrN Word8 n -> IO ()) -> ByteStringN n @-}
create' n fill = unsafePerformIO $ do
  fp  <- mallocForeignPtrBytes n
  withForeignPtr fp fill
  return (BS fp 0 n)
</div>
</div>

</div>

</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Assuming, of course, the absence of errors in the
compiler and run-time…<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>We elide the <code>Storable</code> type class constraint
to strip this presentation down to the absolute essentials.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>In Vim or Emacs or online, you’d see the error helpfully
highlighted.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This is another <em>ghost</em> specification.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>This signature precludes <em>left</em> or
<em>backward</em> shifts; for that there is an analogous
<code>minusPtr</code> which we elide for simplicity.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Did you notice that we have strengthened the type of
<code>plusPtr</code> to prevent the pointer from wandering outside the
boundary of the buffer? We could instead use a weaker requirement for
<code>plusPtr</code> that omits this requirement, and instead have the
error be flagged when the pointer was used to read or write memory.<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>If we so desire, we can also <em>check</em> the boundary
specifications at <a
href="http://en.wikipedia.org/wiki/Design_by_contract">run-time</a>, but
that is outside the scope of LiquidHaskell.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>The code uses <code>create'</code> which is just
<code>create</code> with the <em>correct</em> signature in case you want
to skip the previous exercise. (But don’t!)<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><code>peekByteOff p i</code> is equivalent to
<code>peek (plusPtr p i)</code>.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquid-demo.programming.systems/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
