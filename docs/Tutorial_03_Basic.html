<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Programming with Refinement Types</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Tutorial_01_Introduction.html'><b>1.</b>Introduction {#intro}</a></li>
<ul class='section'>
<li><a href='Tutorial_01_Introduction.html#'><b>1.1.</b> Well-Typed Programs Do Go Wrong {#gowrong}</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.2.</b> Refinement Types</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.3.</b> Audience</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.4.</b> Getting Started</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.5.</b> Sample Code</a></li>
</ul>
<li><a href='Tutorial_02_Logic.html'><b>2.</b>Logic &amp; SMT</a></li>
<ul class='section'>
<li><a href='Tutorial_02_Logic.html#'><b>2.1.</b> Syntax</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.2.</b> Semantics {#semantics}</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.3.</b> Verification Conditions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.4.</b> Examples: Propositions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.5.</b> Examples: Arithmetic</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.6.</b> Examples: Uninterpreted Function</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_03_Basic.html'><b>3.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Tutorial_03_Basic.html#'><b>3.1.</b> Defining Types {#definetype}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.2.</b> Errors</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.3.</b> Subtyping</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.4.</b> Writing Specifications</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.5.</b> Refining Function Types: Pre-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.6.</b> Refining Function Types: Post-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.7.</b> Testing Values: Booleans and Propositions {#propositions}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.8.</b> Putting It All Together</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.9.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_04_Polymorphism.html'><b>4.</b>Polymorphism {#polymorphism}</a></li>
<ul class='section'>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.1.</b> Specification: Vector Bounds {#vectorbounds}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.2.</b> Verification: Vector Lookup</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.3.</b> Inference: Our First Recursive Function</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.4.</b> Higher-Order Functions: Bottling Recursion in a <code>loop</code></a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.5.</b> Refinements and Polymorphism {#sparsetype}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.6.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_05_Datatypes.html'><b>5.</b>Refined Datatypes {#refineddatatypes}</a></li>
<ul class='section'>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.1.</b> Sparse Vectors Revisited {#autosmart}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.2.</b> Ordered Lists {#orderedlists}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.3.</b> Ordered Trees {#binarysearchtree}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_06_Measure_Bool.html'><b>6.</b>Boolean Measures {#boolmeasures}</a></li>
<ul class='section'>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.1.</b> Partial Functions</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.2.</b> Lifting Functions to Measures {#usingmeasures}</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.3.</b> A Safe List API</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_07_Measure_Int.html'><b>7.</b>Numeric Measures {#numericmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.1.</b> Wholemeal Programming</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.2.</b> Specifying List Dimensions</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.3.</b> Lists: Size Preserving API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.4.</b> Lists: Size Reducing API {#listreducing}</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.5.</b> Dimension Safe Vector API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.6.</b> Dimension Safe Matrix API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_08_Measure_Set.html'><b>8.</b>Elemental Measures {#setmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.1.</b> Talking about Sets</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.2.</b> Proving QuickCheck Style Properties {#quickcheck}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.3.</b> Content-Aware List API {#listelems}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.4.</b> Permutations</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.5.</b> Uniqueness</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.6.</b> Unique Zippers</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html'><b>9.</b>Case Study: Okasaki's Lazy Queues {#lazyqueue}</a></li>
<ul class='section'>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.1.</b> Queues</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.2.</b> Sized Lists</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.3.</b> Queue Type</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.4.</b> Queue Operations</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.5.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html'><b>10.</b>Case Study: Associative Maps</a></li>
<ul class='section'>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.1.</b> Specifying Maps {#mapapi}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.2.</b> Using Maps: Well Scoped Expressions</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.3.</b> Implementing Maps: Binary Search Trees {#lemmas}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_11_Case_Study_Pointers.html'><b>11.</b>Case Study: Pointers &amp; Bytes {#case-study-pointers}</a></li>
<ul class='section'>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.1.</b> HeartBleeds in Haskell</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.2.</b> Low-level Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.3.</b> A Refined Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.4.</b> Assumptions vs Guarantees</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.5.</b> ByteString API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.6.</b> Application API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.7.</b> Nested ByteStrings</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.8.</b> Recap: Types Against Overflows</a></li>
</ul>
<li><a href='Tutorial_12_Case_Study_AVL.html'><b>12.</b>Case Study: AVL Trees {#case-study-avltree}</a></li>
<ul class='section'>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.1.</b> AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.2.</b> Specifying AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.3.</b> Smart Constructors</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.4.</b> Inserting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.5.</b> Rebalancing Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.6.</b> Refactoring Rebalance</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.7.</b> Deleting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.8.</b> Functional Correctness</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="refinement-types" class="level1">
<h1>Refinement Types</h1>
<div class="hidden">
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{-@ LIQUID "--short-names" @-}
{-@ LIQUID "--no-termination" @-}
module Tutorial_03_Basic where

import Prelude hiding (abs)
divide  :: Int -> Int -> Int
die     :: String -> a

-- {-@ fail nonsense  @-}
-- {-@ fail canDie    @-}
-- {-@ fail divide'   @-}
-- {-@ fail avg       @-}
-- {-@ ignore lAssert @-}

</div>
</div>

</div>

<p><br />
<strong>What is a Refinement Type?</strong> In a nutshell,</p>
<blockquote>
<p><em>Refinement Types</em> = <em>Types</em> + <em>Predicates</em></p>
</blockquote>
<p> That is, refinement types allow us to decorate types with
<em>logical predicates</em>, which you can think of as
<em>boolean-valued</em> Haskell expressions, that constrain the set of
values described by the type. This lets us specify sophisticated
invariants of the underlying values.</p>
<section id="definetype" class="level2">
<h2>Defining Types</h2>
<p>Let us define some refinement types:<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">{-@ type Zero    = {v:Int | v == 0} @-}
{-@ type NonZero = {v:Int | v /= 0} @-}</div>
</div>

<p><br />
<strong>The Value Variable</strong> <code>v</code> denotes the set of
valid inhabitants of each refinement type. Hence, <code>Zero</code>
describes the <em>set of</em> <code>Int</code> values that are equal to
<code>0</code>, that is, the singleton set containing just
<code>0</code>, and <code>NonZero</code> describes the set of
<code>Int</code> values that are <em>not</em> equal to <code>0</code>,
that is, the set <code>{1, -1, 2, -2, ...}</code> and so on. <a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
<p><br />
<strong>To use</strong> these types we can write:</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ zero :: Zero @-}
zero  = 0 :: Int

{-@ one, two, three :: NonZero @-}
one   = 1 :: Int
two   = 2 :: Int
three = 3 :: Int</div>
</div>

</section>
<section id="errors" class="level2">
<h2>Errors</h2>
<p>If we try to say nonsensical things like:</p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">nonsense :: Int
nonsense = one'
  where
  {-@ one' :: Zero @-}
  one' = 1 </div>
</div>

<p> LiquidHaskell will complain with an error message:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">../liquidhaskell-tutorial/src/03-basic.lhs:72:3-6:</span> Error: Liquid Type Mismatch</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">72</span> <span class="kw">|</span>   <span class="ex">one</span><span class="st">&#39; = 1 :: Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="st">       ^^^^</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">  Inferred type</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">    VV : {VV : Int | VV == (1 : int)}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="st">  not a subtype of Required type</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="st">    VV : {VV : Int | VV == 0}</span></span></code></pre></div>
<p> The message says that the expression <code>1 :: Int</code> has the
type</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">{v:Int</span> <span class="kw">|</span> <span class="ex">v</span> == 1}</span></code></pre></div>
<p> which is <em>not</em> (a subtype of) the <em>required</em> type</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">{v:Int</span> <span class="kw">|</span> <span class="ex">v</span> == 0}</span></code></pre></div>
<p> as <code>1</code> is not equal to <code>0</code>.</p>
</section>
<section id="subtyping" class="level2">
<h2>Subtyping</h2>
<p>What is this business of <em>subtyping</em>? Suppose we have some
more refinements of <code>Int</code></p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">{-@ type Nat   = {v:Int | 0 <= v}        @-}
{-@ type Even  = {v:Int | v mod 2 == 0 } @-}
{-@ type Lt100 = {v:Int | v < 100}       @-}</div>
</div>

<p><br />
<strong>What is the type of</strong> <code>zero</code>?
<code>Zero</code> of course, but also <code>Nat</code>:</p>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">{-@ zero' :: Nat @-}
zero'     = zero</div>
</div>

<p> and also <code>Even</code>:</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ zero'' :: Even @-}
zero''     = zero</div>
</div>

<p> and also any other satisfactory refinement, such as <a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ zero''' :: Lt100  @-}
zero'''     = zero</div>
</div>

<p><code>Zero</code> is the most precise type for <code>0::Int</code>,
as it is a <em>subtype</em> of <code>Nat</code>, <code>Even</code> and
<code>Lt100</code>. This is because the set of values defined by
<code>Zero</code> is a <em>subset</em> of the values defined by
<code>Nat</code>, <code>Even</code> and <code>Lt100</code>, as the
following <em>logical implications</em> are valid:</p>
<ul>
<li><span class="math inline">\(v = 0 \Rightarrow 0 \leq v\)</span></li>
<li><span class="math inline">\(v = 0 \Rightarrow v \ \mbox{mod}\ 2 =
0\)</span></li>
<li><span class="math inline">\(v = 0 \Rightarrow v &lt;
100\)</span></li>
</ul>
<p><br />
<strong>In Summary</strong> the key points about refinement types
are:</p>
<ol type="1">
<li>A refinement type is just a type <em>decorated</em> with logical
predicates.</li>
<li>A term can have <em>different</em> refinements for different
properties.</li>
<li>When we <em>erase</em> the predicates we get the standard Haskell
types.<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></li>
</ol>
</section>
<section id="writing-specifications" class="level2">
<h2>Writing Specifications</h2>
<p>Let’s write some more interesting specifications.</p>
<p><br />
<strong>Typing Dead Code</strong> We can wrap the usual
<code>error</code> function in a function <code>die</code> with the
type:</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ die :: {v:String | false} -> a  @-}
die msg = error msg</div>
</div>

<p>The interesting thing about <code>die</code> is that the input type
has the refinement <code>false</code>, meaning the function must only be
called with <code>String</code>s that satisfy the predicate
<code>false</code>. This seems bizarre; isn’t it <em>impossible</em> to
satisfy <code>false</code>? Indeed! Thus, a program containing
<code>die</code> typechecks <em>only</em> when LiquidHaskell can prove
that <code>die</code> is <em>never called</em>. For example,
LiquidHaskell will <em>accept</em></p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">cannotDie = if 1 + 1 == 3
              then die "horrible death"
              else ()</div>
</div>

<p> by inferring that the branch condition is always <code>False</code>
and so <code>die</code> cannot be called. However, LiquidHaskell will
<em>reject</em></p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">canDie = if 1 + 1 == 2
           then die "horrible death"
           else ()</div>
</div>

<p> as the branch may (will!) be <code>True</code> and so
<code>die</code> can be called.</p>
</section>
<section id="refining-function-types-pre-conditions" class="level2">
<h2>Refining Function Types: Pre-conditions</h2>
<p>Let’s use <code>die</code> to write a <em>safe division</em> function
that <em>only accepts</em> non-zero denominators.</p>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">divide'     :: Int -> Int -> Int
divide' n 0 = die "divide by zero"
divide' n d = n `div` d</div>
</div>

<p>From the above, it is clear to <em>us</em> that <code>div</code> is
only called with non-zero divisors. However, LiquidHaskell reports an
error at the call to <code>"die"</code> because, what if
<code>divide'</code> is actually invoked with a <code>0</code>
divisor?</p>
<p>We can specify that will not happen, with a <em>pre-condition</em>
that says that the second argument is non-zero:</p>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">{-@ divide :: Int -> NonZero -> Int @-}
divide _ 0 = die "divide by zero"
divide n d = n `div` d</div>
</div>

<p><br />
<strong>To Verify</strong> that <code>divide</code> never calls
<code>die</code>, LiquidHaskell infers that
<code>"divide by zero"</code> is not merely of type <code>String</code>,
but in fact has the the refined type <code>{v:String | false}</code>
<em>in the context</em> in which the call to <code>die</code> occurs.
LiquidHaskell arrives at this conclusion by using the fact that in the
first equation for <code>divide</code> the <em>denominator</em> is in
fact</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">0</span> :: {v: Int <span class="kw">|</span> <span class="ex">v</span> == 0}</span></code></pre></div>
<p> which <em>contradicts</em> the pre-condition (i.e. input) type.
Thus, by contradiction, LiquidHaskell deduces that the first equation is
<em>dead code</em> and hence <code>die</code> will not be called at
run-time.</p>
<p>The above signature forces us to ensure that that when we
<em>use</em> <code>divide</code>, we only supply provably
<code>NonZero</code> arguments. Hence, these two uses of
<code>divide</code> are fine:</p>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">avg2 x y   = divide (x + y) 2
avg3 x y z = divide (x + y + z) 3</div>
</div>

<div id="List Average" class="hwex">
<p><br />
<strong>Exercise: (List Average): </strong>Consider the function
<code>avg</code>:</p>
<ol type="1">
<li>Why does LiquidHaskell flag an error at <code>n</code> ?</li>
<li>How can you change the code so LiquidHaskell verifies it?</li>
</ol>
<br />
<br />

</div>
<div id="program-pane-14" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-14" class="programbox">avg       :: [Int] -> Int
avg xs    = divide total n
  where
    total = sum xs
    n     = length xs</div>
</div>

</section>
<section id="refining-function-types-post-conditions" class="level2">
<h2>Refining Function Types: Post-conditions</h2>
<p>Next, let’s see how we can use refinements to describe the
<em>outputs</em> of a function. Consider the following simple
<em>absolute value</em> function</p>
<div id="program-pane-15" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-15" class="programbox">abs           :: Int -> Int
abs n
  | 0 < n     = n
  | otherwise = 0 - n</div>
</div>

<p>We can use a refinement on the output type to specify that the
function returns non-negative values</p>
<div id="program-pane-16" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-16" class="programbox">{-@ abs :: Int -> Nat @-}</div>
</div>

<p>LiquidHaskell <em>verifies</em> that <code>abs</code> indeed enjoys
the above type by deducing that <code>n</code> is trivially non-negative
when <code>0 &lt; n</code> and that in the <code>otherwise</code> case,
the value <code>0 - n</code> is indeed non-negative. <a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
</section>
<section id="propositions" class="level2">
<h2>Testing Values: Booleans and Propositions</h2>
<p>In the above example, we <em>compute</em> a value that is guaranteed
to be a <code>Nat</code>. Sometimes, we need to <em>test</em> if a value
satisfies some property, e.g., is <code>NonZero</code>. For example,
let’s write a command-line <em>calculator</em>:</p>
<div id="program-pane-17" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-17" class="programbox">calc = do putStrLn "Enter numerator"
          n <- readLn
          putStrLn "Enter denominator"
          d <- readLn
          putStrLn (result n d)
          calc</div>
</div>

<p>which takes two numbers and divides them. The function
<code>result</code> checks if <code>d</code> is strictly positive (and
hence, non-zero), and does the division, or otherwise complains to the
user:</p>
<div id="program-pane-18" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-18" class="programbox">result n d
  | isPositive d = "Result = " ++ show (n `divide` d)
  | otherwise    = "Humph, please enter positive denominator!"</div>
</div>

<p>Finally, <code>isPositive</code> is a test that returns a
<code>True</code> if its input is strictly greater than <code>0</code>
or <code>False</code> otherwise:</p>
<div id="program-pane-19" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-19" class="programbox">isPositive :: Int -> Bool
isPositive x = x > 0</div>
</div>

<p><br />
<strong>To verify</strong> the call to <code>divide</code> inside
<code>result</code> we need to tell LiquidHaskell that the division only
happens with a <code>NonZero</code> value <code>d</code>. However, the
non-zero-ness is established via the <em>test</em> that occurs inside
the guard <code>isPositive d</code>. Hence, we require a
<em>post-condition</em> that states that <code>isPositive</code> only
returns <code>True</code> when the argument is positive:</p>
<div id="program-pane-20" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-20" class="programbox">{-@ isPositive :: x:Int -> {v:Bool | v <=> x > 0} @-}</div>
</div>

<p>In the above signature, the output type (post-condition) states that
<code>isPositive x</code> returns <code>True</code> if and only if
<code>x</code> was in fact strictly greater than <code>0</code>. In
other words, we can write post-conditions for plain-old
<code>Bool</code>-valued <em>tests</em> to establish that user-supplied
values satisfy some desirable property (here, <code>Pos</code> and hence
<code>NonZero</code>) in order to then safely perform some computation
on it.</p>
<div id="Propositions" class="hwex">
<p><br />
<strong>Exercise: (Propositions): </strong>What happens if you
<em>delete</em> the type for <code>isPositive</code> ? Can you
<em>change</em> the type for <code>isPositive</code> (i.e. write some
other type) while preserving safety?</p>
<br />
<br />

</div>
<div id="Assertions" class="hwex">
<p><br />
<strong>Exercise: (Assertions): </strong>Consider the following <a
href="https://www.haskell.org/hoogle/?hoogle=assert">assert</a>
function, and two use sites. Write a suitable refinement type signature
for <code>lAssert</code> so that <code>lAssert</code> and
<code>yes</code> are accepted but <code>no</code> is rejected.</p>
<br />
<br />

</div>
<div id="program-pane-21" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-21" class="programbox">{-@ lAssert  :: Bool -> a -> a @-}
lAssert True  x = x
lAssert False _ = die "yikes, assertion fails!"

yes = lAssert (1 + 1 == 2) ()
no  = lAssert (1 + 1 == 3) ()</div>
</div>

<p><strong>Hint: </strong>You need a pre-condition that
<code>lAssert</code> is only called with <code>True</code>.</p>
</section>
<section id="putting-it-all-together" class="level2">
<h2>Putting It All Together</h2>
<p>Let’s wrap up this introduction with a simple <code>truncate</code>
function that connects all the dots.</p>
<div id="program-pane-22" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-22" class="programbox">truncate :: Int -> Int -> Int
truncate i max
  | i' <= max' = i
  | otherwise  = max' * (i `divide` i')
    where
      i'       = abs i
      max'     = abs max</div>
</div>

<p> The expression <code>truncate i n</code> evaluates to <code>i</code>
when the absolute value of <code>i</code> is less than the upper bound
<code>max</code>, and otherwise <em>truncates</em> the value at the
maximum <code>n</code>. LiquidHaskell verifies that the use of
<code>divide</code> is safe by inferring that:</p>
<ol type="1">
<li><code>max' &lt; i'</code> from the branch condition,</li>
<li><code>0 &lt;= i'</code> from the <code>abs</code> post-condition,
and</li>
<li><code>0 &lt;= max'</code> from the <code>abs</code>
post-condition.</li>
</ol>
<p>From the above, LiquidHaskell infers that <code>i' /= 0</code>. That
is, at the call site <code>i' :: NonZero</code>, thereby satisfying the
pre-condition for <code>divide</code> and verifying that the program has
no pesky divide-by-zero errors.</p>
</section>
<section id="recap" class="level2">
<h2>Recap</h2>
<p>This concludes our quick introduction to Refinement Types and
LiquidHaskell. Hopefully you have some sense of how to</p>
<ol type="1">
<li><strong>Specify</strong> fine-grained properties of values by
decorating their types with logical predicates.</li>
<li><strong>Encode</strong> assertions, pre-conditions, and
post-conditions with suitable function types.</li>
<li><strong>Verify</strong> semantic properties of code by using
automatic logic engines (SMT solvers) to track and establish the key
relationships between program values.</li>
</ol>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>You can read the type of <code>Zero</code> as:
“<code>v</code> is an <code>Int</code> <em>such that</em> <code>v</code>
equals <code>0</code>” and <code>NonZero</code> as : “<code>v</code> is
an <code>Int</code> <em>such that</em> <code>v</code> does not equal
<code>0</code>”<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>We will use <code>@</code>-marked comments to write
refinement type annotations in the Haskell source file, making these
types, quite literally, machine-checked comments!<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>We use a different names <code>zero'</code>,
<code>zero''</code> etc. as (currently) LiquidHaskell supports <em>at
most</em> one refinement type for each top-level name.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Dually, a standard Haskell type has the trivial
refinement <code>true</code>. For example, <code>Int</code> is
equivalent to <code>{v:Int|true}</code>.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>LiquidHaskell is able to automatically make these
arithmetic deductions by using an <a
href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">SMT
solver</a> which has built-in decision procedures for arithmetic, to
reason about the logical refinements.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquid-demo.programming.systems/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
