<!DOCTYPE html>
<html lang="en">
<head>

<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106754474-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-106754474-1');
</script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Programming with Refinement Types</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

   
    <style type="text/css">code{white-space: pre;}

      .dropdown-menu {
          min-width: 0px;
      }
      
      #checker-status {
          width: 30;
          height: 20;
          padding-top: 2px;
          padding-right: 10px;
          position: absolute;
          top: 0;
          right: 0;
          z-index:99;
      }
    </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>


<!-- <script type="text/javascript" src="js/jquery/jquery-1.7.1.min.js"></script> -->
<script type="text/javascript" src="./js/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="./js/angular/angular.js"></script>
<script type="text/javascript" src="./js/bootstrap/bootstrap.js"></script>

<!-- MATHJAX TEMPLATES GO HERE -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    extensions: ["color.js"],
    Macros: {
      True: "\\mathit{True}",
      RR:   "{\\bf R}",
      Int:  "\\mathtt{Int}",
      Nat:  "\\mathtt{Nat}",
      Zero: "\\mathtt{Zero}",
      foo:   ["{\\bf Jhala FOO #1}", 1],
      kvar:  ["{\\color[rgb]{1,0,0}{K_{#1}({#2})}}", 2],
      bindx: ["{{#1}\\!:\\!{#2}}", 2],
      reft:  ["\\{\\bindx{#1}{#2} \\mid {#3}\\}", 3],
      ereft: ["\\bindx{#1}{\\{#2 \\mid #3\\}}", 3],
      reftx: ["\\{{#1}\\mid{#2}\\}", 2],
      inferrule: ["\\frac{#2}{#3}\\;{#1}", 3],
      tcap:  ["(\\mathtt{intersection}\\ #1\\ #2)", 2],
      tcup:  ["(\\mathtt{union}\\ #1\\ #2)", 2],
      tsng:  ["(\\mathtt{singleton}\\ #1)", 1]
  }
  }
});
</script>

<!-- GITHUB -->
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>
  
<!-- LOCAL 

  <script src="js/MathJax-2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>
    
  -->
  







</head>
<body class="rustdoc" data-spy="scroll" data-target=".bs-docs-sidebar" ng-app="liquidDemo" ng-controller="LiquidDemoCtrl">

    <div id="nav">
       <button id="toggle-nav" class="toggle-nav">
         <span class="sr-only">Toggle navigation</span>
         <span class="bar"></span>
         <span class="bar"></span>
         <span class="bar"></span>
       </button>
    </div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='Tutorial_01_Introduction.html'><b>1.</b>Introduction {#intro}</a></li>
<ul class='section'>
<li><a href='Tutorial_01_Introduction.html#'><b>1.1.</b> Well-Typed Programs Do Go Wrong {#gowrong}</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.2.</b> Refinement Types</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.3.</b> Audience</a></li>
<li><a href='Tutorial_01_Introduction.html#'><b>1.4.</b> Getting Started</a></li>
</ul>
<li><a href='Tutorial_02_Logic.html'><b>2.</b>Logic &amp; SMT</a></li>
<ul class='section'>
<li><a href='Tutorial_02_Logic.html#'><b>2.1.</b> Syntax</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.2.</b> Semantics {#semantics}</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.3.</b> Verification Conditions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.4.</b> Examples: Propositions</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.5.</b> Examples: Arithmetic</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.6.</b> Examples: Uninterpreted Function</a></li>
<li><a href='Tutorial_02_Logic.html#'><b>2.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_03_Basic.html'><b>3.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Tutorial_03_Basic.html#'><b>3.1.</b> Defining Types {#definetype}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.2.</b> Errors</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.3.</b> Subtyping</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.4.</b> Writing Specifications</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.5.</b> Refining Function Types: Pre-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.6.</b> Refining Function Types: Post-conditions</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.7.</b> Testing Values: Booleans and Propositions {#propositions}</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.8.</b> Putting It All Together</a></li>
<li><a href='Tutorial_03_Basic.html#'><b>3.9.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_04_Polymorphism.html'><b>4.</b>Polymorphism {#polymorphism}</a></li>
<ul class='section'>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.1.</b> Specification: Vector Bounds {#vectorbounds}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.2.</b> Verification: Vector Lookup</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.3.</b> Inference: Our First Recursive Function</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.4.</b> Higher-Order Functions: Bottling Recursion in a <code>loop</code></a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.5.</b> Refinements and Polymorphism {#sparsetype}</a></li>
<li><a href='Tutorial_04_Polymorphism.html#'><b>4.6.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_05_Datatypes.html'><b>5.</b>Refined Datatypes {#refineddatatypes}</a></li>
<ul class='section'>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.1.</b> Sparse Vectors Revisited {#autosmart}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.2.</b> Ordered Lists {#orderedlists}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.3.</b> Ordered Trees {#binarysearchtree}</a></li>
<li><a href='Tutorial_05_Datatypes.html#'><b>5.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_06_Measure_Bool.html'><b>6.</b>Boolean Measures {#boolmeasures}</a></li>
<ul class='section'>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.1.</b> Partial Functions</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.2.</b> Lifting Functions to Measures {#usingmeasures}</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.3.</b> A Safe List API</a></li>
<li><a href='Tutorial_06_Measure_Bool.html#'><b>6.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_07_Measure_Int.html'><b>7.</b>Numeric Measures {#numericmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.1.</b> Wholemeal Programming</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.2.</b> Specifying List Dimensions</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.3.</b> Lists: Size Preserving API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.4.</b> Lists: Size Reducing API {#listreducing}</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.5.</b> Dimension Safe Vector API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.6.</b> Dimension Safe Matrix API</a></li>
<li><a href='Tutorial_07_Measure_Int.html#'><b>7.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_08_Measure_Set.html'><b>8.</b>Elemental Measures {#setmeasure}</a></li>
<ul class='section'>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.1.</b> Talking about Sets</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.2.</b> Proving QuickCheck Style Properties {#quickcheck}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.3.</b> Content-Aware List API {#listelems}</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.4.</b> Permutations</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.5.</b> Uniqueness</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.6.</b> Unique Zippers</a></li>
<li><a href='Tutorial_08_Measure_Set.html#'><b>8.7.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html'><b>9.</b>Case Study: Okasaki's Lazy Queues {#lazyqueue}</a></li>
<ul class='section'>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.1.</b> Queues</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.2.</b> Sized Lists</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.3.</b> Queue Type</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.4.</b> Queue Operations</a></li>
<li><a href='Tutorial_09_Case_Study_Lazy_Queues.html#'><b>9.5.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html'><b>10.</b>Case Study: Associative Maps</a></li>
<ul class='section'>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.1.</b> Specifying Maps {#mapapi}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.2.</b> Using Maps: Well Scoped Expressions</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.3.</b> Implementing Maps: Binary Search Trees {#lemmas}</a></li>
<li><a href='Tutorial_10_Case_Study_Associative_Maps.html#'><b>10.4.</b> Recap</a></li>
</ul>
<li><a href='Tutorial_11_Case_Study_Pointers.html'><b>11.</b>Case Study: Pointers &amp; Bytes {#case-study-pointers}</a></li>
<ul class='section'>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.1.</b> HeartBleeds in Haskell</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.2.</b> Low-level Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.3.</b> A Refined Pointer API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.4.</b> Assumptions vs Guarantees</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.5.</b> ByteString API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.6.</b> Application API</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.7.</b> Nested ByteStrings</a></li>
<li><a href='Tutorial_11_Case_Study_Pointers.html#'><b>11.8.</b> Recap: Types Against Overflows</a></li>
</ul>
<li><a href='Tutorial_12_Case_Study_AVL.html'><b>12.</b>Case Study: AVL Trees {#case-study-avltree}</a></li>
<ul class='section'>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.1.</b> AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.2.</b> Specifying AVL Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.3.</b> Smart Constructors</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.4.</b> Inserting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.5.</b> Rebalancing Trees</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.6.</b> Refactoring Rebalance</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.7.</b> Deleting Elements</a></li>
<li><a href='Tutorial_12_Case_Study_AVL.html#'><b>12.8.</b> Functional Correctness</a></li>
</ul>
</ul>

</div>
      
       <div id="checker-status">
         <!-- Verifying ... -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; z-index:1"
                ng-show="isChecking" ng-click="verifySource()">
          <span class="glyphicon glyphicon-hourglass"></span>
         </button>

        
         <!-- Safe -->
         <button class="btn btn-xs btn-link actbutton" type="button" style="font-size:30px; color:green; z-index:1"
                 ng-show="isSafe">
           <span class="glyphicon glyphicon-ok"></span>
         </button>

         <div class="dropdown" ng-show="isBad">
             <button class="btn btn-xs btn-link dropdown-toggle"
                     type="button"
                     id="errorblockdropdown"
                     data-toggle="dropdown"
                     style="font-size:30px; color:red; z-index:1">
               <span class="glyphicon glyphicon-remove" style="vertical-align:middle"></span><font size="4">{{errorBlocks.length}}</font>
               </span>
             </button>
             <ul class="dropdown-menu" role="menu" aria-labelledby="dLabel">
               <li ng-repeat="err in errorBlocks">
                 <a tabindex="-1" ng-href="#program-{{err.data}}">{{err.index}}</a>
               </li>
             </ul>
         </div>
       </div>
       

<div id='page-wrapper'>
<div id='page'>

<section id="setmeasure" class="level1">
<h1>Elemental Measures</h1>
<div class="hidden">
<div id="program-pane-0" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-0" class="programbox">{-@ LIQUID "--no-termination" @-}

module Tutorial_08_Measure_Set where
import Data.Set hiding (insert, partition, filter, split, elems)
import Prelude  hiding (elem, reverse, filter)

main :: IO ()
main = return ()

{-@ die :: {v:_ | false} -> a @-}
die msg = error msg

isUnique, isNotUnique :: [Int]
mergeSort :: (Ord a) => [a] -> [a]
range :: Int -> Int -> [Int]
-- FIXME
{-@ predicate In X Xs      = Set_mem X Xs            @-}
{-@ predicate Subset X Y   = Set_sub X Y             @-}
{-@ predicate Empty  X     = Set_emp X               @-}
{-@ predicate Inter X Y Z  = X = Set_cap Y Z         @-}
{-@ predicate Union X Y Z  = X = Set_cup Y Z         @-}
{-@ predicate Union1 X Y Z = Union X (Set_sng Y) Z   @-}
{-@ predicate Disjoint X Y = Inter (Set_empty 0) X Y @-}
type List a = [a]

-- {-@ fail prop_x_y_200 @-}
-- {-@ fail prop_cup_dif_bad @-}
-- {-@ fail reverse' @-}
-- {-@ fail prop_halve_append @-}
-- {-@ fail test1 @-}
-- {-@ fail test2 @-}
-- {-@ fail test2 @-}
-- {-@ fail test3 @-}
-- {-@ fail prop_merge_app @-}
-- {-@ ignore mergeSort @-}
-- {-@ fail isNotUnique @-}
-- {-@ ignore append @-}
-- {-@ ignore range @-}
-- {-@ ignore integrate @-}
-- {-@ ignore focusLeft @-}


</div>
</div>

</div>

<p>Often, correctness requires us to reason about the <em>set of
elements</em> represented inside a data structure, or manipulated by a
function. Examples of this abound: for example, we’d like to know
that:</p>
<ul>
<li><p><em>sorting</em> routines return permutations of their inputs –
i.e. return collections whose elements are the same as the input
set,</p></li>
<li><p><em>resource</em> management functions do not inadvertently
create duplicate elements or drop elements from set of tracked
resources.</p></li>
<li><p><em>syntax-tree</em> manipulating procedures create well-scoped
trees where the set of used variables are contained within the set of
variables previously defined.</p></li>
</ul>
<p><br />
<strong>SMT Solvers</strong> support very expressive logics. In addition
to linear arithmetic and uninterpreted functions, they can <a
href="http://www.kroening.com/smt-lib-lsm.pdf">efficiently decide</a>
formulas over sets. Next, let’s see how LiquidHaskell lets us exploit
this fact to develop types and interfaces that guarantee invariants over
the set of elements of a structures.</p>
<section id="talking-about-sets" class="level2">
<h2>Talking about Sets</h2>
<p>First, we need a way to talk about sets in the refinement logic. We
could roll our own special Haskell type but for now, let’s just use the
<code>Set a</code> type from the prelude’s <code>Data.Set</code>.<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p><br />
<strong>LiquidHaskell Lifts</strong> the basic set operators from
<code>Data.Set</code> into the refinement logic. That is, the prelude
defines the following <em>logical</em> functions that correspond to the
<em>Haskell</em> functions of the same name:</p>
<pre class="spec"><code>measure empty        :: Set a
measure singleton    :: a -&gt; Set a
measure member       :: a -&gt; Set a -&gt; Bool
measure union        :: Set a -&gt; Set a -&gt; Set a
measure intersection :: Set a -&gt; Set a -&gt; Set a
measure difference   :: Set a -&gt; Set a -&gt; Set a</code></pre>
<p>The above operators are <em>interpreted</em> by the SMT solver. That
is, just like the SMT solver “knows”, via the axioms of the theory of
arithmetic that: <span class="math display">\[x = 1 + 1 \Rightarrow x =
2\]</span> is a valid formula, i.e. holds for all <span
class="math inline">\(x\)</span>, the solver “knows” that: <span
class="math display">\[x = \tsng{1} \Rightarrow y = \tsng{2} \Rightarrow
x = \tcap{x}{\tcup{y}{x}}\]</span> This is because, the above formulas
belong to a decidable Theory of Sets reduces to McCarthy’s more general
<a href="http://www-formal.stanford.edu/jmc/towards.ps">Theory of
Arrays</a>. <a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
</section>
<section id="quickcheck" class="level2">
<h2>Proving QuickCheck Style Properties</h2>
<p>To get the hang of whats going on, let’s do a few warm up exercises,
using LiquidHaskell to prove various simple theorems about sets and
operations over them.</p>
<p><br />
<strong>We Refine The Set API</strong> to make it easy to write down
theorems. That is, we give the operators in <code>Data.Set</code>
refinement type signatures that precisely track their set-theoretic
behavior:</p>
<pre class="spec"><code>empty        :: {v:Set a | v = empty}
member       :: x:a
             -&gt; s:Set a
             -&gt; {v:Bool | v &lt;=&gt; member x s}

singleton    :: x:a -&gt; {v:Set a | v = singleton x}

union        :: x:Set a
             -&gt; y:Set a
             -&gt; {v:Set a | v = union x y}

intersection :: x:Set a
             -&gt; y:Set a
             -&gt; {v:Set a | v = intersection x y}

difference   :: x:Set a
             -&gt; y:Set a
             -&gt; {v:Set a | v = difference x y}</code></pre>
<p><br />
<strong>We Can Assert Theorems</strong> as <a
href="quickcheck">QuickCheck</a> style <em>properties</em>, that is, as
functions from arbitrary inputs to a <code>Bool</code> output that must
always be <code>True</code>. Lets define aliases for the
<code>Bool</code>eans that are always <code>True</code> or
<code>False</code></p>
<div id="program-pane-1" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-1" class="programbox">{-@ type True  = {v:Bool |     v} @-}
{-@ type False = {v:Bool | not v} @-}</div>
</div>

<p>We can use <code>True</code> to state theorems. For example, the
unexciting arithmetic equality above becomes:</p>
<div id="program-pane-2" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-2" class="programbox">{-@ prop_one_plus_one_eq_two :: _ -> True @-}
prop_one_plus_one_eq_two x   = (x == 1 + 1) `implies` (x == 2)</div>
</div>

<p>Where <code>implies</code> is just the implication function over
<code>Bool</code></p>
<div id="program-pane-3" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-3" class="programbox">{-@ implies        :: p:Bool -> q:Bool -> Implies p q  @-}
implies False _    = True
implies _     True = True
implies _    _     = False</div>
</div>

<p>and <code>Implies p q</code> is defined as</p>
<div id="program-pane-4" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-4" class="programbox">{-@ type Implies P Q = {v:_ | v <=> (P => Q)} @-}</div>
</div>

<div id="Bounded Addition" class="hwex">
<p><br />
<strong>Exercise: (Bounded Addition): </strong>Write and prove a
QuickCheck style theorem that: <span class="math inline">\(\forall x, y.
x &lt; 100 \wedge y &lt; 100 \Rightarrow x + y &lt; 200\)</span>.</p>
<br />
<br />

</div>
<div id="program-pane-5" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-5" class="programbox">{-@ prop_x_y_200 :: _ -> _ -> True @-}
prop_x_y_200 x y = False -- fill in the theorem body</div>
</div>

<p><br />
<strong>The Commutativity of Intersection</strong> can be easily stated
and proved as a QuickCheck style theorem:</p>
<div id="program-pane-6" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-6" class="programbox">{-@ prop_intersection_comm :: _ -> _ -> True @-}
prop_intersection_comm x y
  = (x `intersection` y) == (y `intersection` x)</div>
</div>

<p><br />
<strong>The Associativity of Union</strong> can similarly be
confirmed:</p>
<div id="program-pane-7" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-7" class="programbox">{-@ prop_union_assoc :: _ -> _ -> _ -> True @-}
prop_union_assoc x y z
  = (x `union` (y `union` z)) == (x `union` y) `union` z</div>
</div>

<p><br />
<strong>The Distributivity Laws</strong> for Boolean Algebra can be
verified by writing properties over the relevant operators. For example,
let’s check that <code>intersection</code> distributes over
<code>union</code>:</p>
<div id="program-pane-8" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-8" class="programbox">{-@ prop_intersection_dist :: _ -> _ -> _ -> True @-}
prop_intersection_dist x y z
  =  x `intersection` (y `union` z)
     ==
     (x `intersection` y) `union` (x `intersection` z)</div>
</div>

<p><br />
<strong>Non-Theorems</strong> should be rejected. So, while we’re at it,
let’s make sure LiquidHaskell doesn’t prove anything that <em>isn’t</em>
true …</p>
<div id="program-pane-9" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-9" class="programbox">{-@ prop_cup_dif_bad :: _ -> _ -> True @-}
prop_cup_dif_bad x y
  = pre `implies` (x == ((x `union` y) `difference` y))
  where
    pre = True  -- Fix this with a non-trivial precondition</div>
</div>

<div id="Set Difference" class="hwex">
<p><br />
<strong>Exercise: (Set Difference): </strong>Why does the above property
fail?</p>
<ol type="1">
<li><p>Use QuickCheck (or your own little grey cells) to find a
<em>counterexample</em> for the property
<code>prop_cup_dif_bad</code>.</p></li>
<li><p>Use the counterexample to assign <code>pre</code> a non-trivial
(i.e. other than <code>False</code>) condition so that the property can
be proved.</p></li>
</ol>
<br />
<br />

</div>
<p>Thus, LiquidHaskell’s refined types offer a nice interface for
interacting with the SMT solvers in order to <em>prove</em> theorems,
while letting us use QuickCheck to generate counterexamples.<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></p>
</section>
<section id="listelems" class="level2">
<h2>Content-Aware List API</h2>
<p>Lets return to our real goal, which is to verify properties of
programs. First, we need a way to refine the list API to precisely track
the set of elements in a list.</p>
<p><br />
<strong>The Elements of a List</strong> can be described by a simple
recursive measure that walks over the list, building up the set:</p>
<div id="program-pane-10" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-10" class="programbox">{-@ measure elts @-}
elts        :: (Ord a) => [a] -> Set a
elts []     = empty
elts (x:xs) = singleton x `union` elts xs</div>
</div>

<p> Lets write a few helpful aliases for various refined lists that will
then make the subsequent specifications pithy and crisp.</p>
<ul>
<li>A list with elements <code>S</code></li>
</ul>
<div id="program-pane-11" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-11" class="programbox">{-@ type ListS a S = {v:[a] | elts v = S} @-}</div>
</div>

<ul>
<li>An <em>empty</em> list</li>
</ul>
<div id="program-pane-12" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-12" class="programbox">{-@ type ListEmp a = ListS a {Set_empty 0} @-}</div>
</div>

<ul>
<li>A list whose contents <em>equal</em> those of list
<code>X</code></li>
</ul>
<div id="program-pane-13" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-13" class="programbox">{-@ type ListEq a X = ListS a {elts X}    @-}</div>
</div>

<ul>
<li>A list whose contents are a <em>subset</em> of list
<code>X</code></li>
</ul>
<div id="program-pane-14" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-14" class="programbox">{-@ type ListSub a X = {v:[a]| Set_sub (elts v) (elts X)} @-}</div>
</div>

<ul>
<li>A list whose contents are the union of lists <code>X</code> and
<code>Y</code></li>
</ul>
<div id="program-pane-15" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-15" class="programbox">{-@ type ListUn a X Y = ListS a {Set_cup (elts X) (elts Y)} @-}</div>
</div>

<ul>
<li>A list whose contents are exactly <code>X</code> and the contents of
<code>Y</code></li>
</ul>
<div id="program-pane-16" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-16" class="programbox">{-@ type ListUn1 a X Y = ListS a {Set_cup (Set_sng X) (elts Y)} @-}</div>
</div>

<p><br />
<strong>The Measures strengthens</strong> the data constructors for
lists. That is we get the automatically refined types for “nil” and
“cons”:</p>
<pre class="spec"><code>data [a] where
  []  :: ListEmp a
  (:) :: x:a -&gt; xs:[a] -&gt; ListUn1 a x xs</code></pre>
<p>Lets take our new vocabulary out for a spin!</p>
<p><br />
<strong>The Append</strong> function returns a list whose elements are
the <em>union</em> of the elements of the input Lists:</p>
<div id="program-pane-17" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-17" class="programbox">{-@ append'       :: xs:_ -> ys:_ -> ListUn a xs ys @-}
append' []     ys = ys
append' (x:xs) ys = x : append' xs ys</div>
</div>

<div id="Reverse" class="hwex">
<p><br />
<strong>Exercise: (Reverse): </strong>Write down a type for
<code>revHelper</code> so that <code>reverse'</code> is verified by
LiquidHaskell.</p>
<br />
<br />

</div>
<div id="program-pane-18" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-18" class="programbox">{-@ reverse' :: xs:[a] -> ListEq a xs @-}
reverse' xs = revHelper [] xs

revHelper acc []     = acc
revHelper acc (x:xs) = revHelper (x:acc) xs</div>
</div>

<div id="Halve" class="hwex">
<p><br />
<strong>Exercise: (Halve): </strong>Write down a specification for
<code>halve</code> such that the subsequent “theorem”
<code>prop_halve_append</code> is proved by LiquidHaskell.</p>
<br />
<br />

</div>
<div id="program-pane-19" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-19" class="programbox">halve            :: Int -> [a] -> ([a], [a])
halve 0 xs       = ([], xs)
halve n (x:y:zs) = (x:xs, y:ys) where (xs, ys) = halve (n-1) zs
halve _ xs       = ([], xs)

{-@ prop_halve_append  :: _ -> _ -> True @-}
prop_halve_append n xs = elts xs == elts xs'
  where
    xs'      =  append' ys zs
    (ys, zs) =  halve n xs</div>
</div>

<p><strong>Hint: </strong>You may want to remind yourself about the
<em>dimension-aware</em> signature for <code>partition</code> from <a
href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/07-measure-int.html#/listreducing">the
earlier chapter</a>.</p>
<div id="Membership" class="hwex">
<p><br />
<strong>Exercise: (Membership): </strong>Write down a signature for
<code>elem</code> that suffices to verify <code>test1</code> and
<code>test2</code>.</p>
<br />
<br />

</div>
<div id="program-pane-20" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-20" class="programbox">{-@ elem      :: (Eq a) => a -> [a] -> Bool @-}
elem _ []     = False
elem x (y:ys) = x == y || elem x ys

{-@ test1 :: True @-}
test1      = elem 2 [1, 2, 3]

{-@ test2 :: False @-}
test2      = elem 2 [1, 3]</div>
</div>

</section>
<section id="permutations" class="level2">
<h2>Permutations</h2>
<p>Next, let’s use the refined list API to prove that various sorting
routines return <em>permutations</em> of their inputs, that is, return
output lists whose elements are the <em>same as</em> those of the input
lists.<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></p>
<p><br />
<strong>Insertion Sort</strong> is the simplest of all the list sorting
routines; we build up an (ordered) output list <code>insert</code>ing
each element of the input list into the appropriate position of the
output:</p>
<div id="program-pane-21" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-21" class="programbox">insert x []     = [x]
insert x (y:ys)
  | x <= y      = x : y : ys
  | otherwise   = y : insert x ys</div>
</div>

<p>Thus, the output of <code>insert</code> has all the elements of the
input <code>xs</code>, plus the new element <code>x</code>:</p>
<div id="program-pane-22" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-22" class="programbox">{-@ insert :: x:a -> xs:[a] -> ListUn1 a x xs @-}</div>
</div>

<p>The above signature lets us prove that the output of the sorting
routine indeed has the elements of the input:</p>
<div id="program-pane-23" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-23" class="programbox">{-@ insertSort :: (Ord a) => xs:[a] -> ListEq a xs @-}
insertSort []     = []
insertSort (x:xs) = insert x (insertSort xs)</div>
</div>

<div id="Merge" class="hwex">
<p><br />
<strong>Exercise: (Merge): </strong>Fix the specification of
<code>merge</code> so that the subsequent property
<code>prop_merge_app</code> is verified by LiquidHaskell.</p>
<br />
<br />

</div>
<div id="program-pane-24" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-24" class="programbox">{-@ merge :: xs:[a] -> ys:[a] -> [a] @-}
merge [] ys          = ys
merge xs []          = xs
merge (x:xs) (y:ys)
  | x <= y           = x : merge xs (y:ys)
  | otherwise        = y : merge (x:xs) ys

{-@ prop_merge_app   :: _ -> _ -> True   @-}
prop_merge_app xs ys = elts zs == elts zs'
  where
    zs               = append' xs ys
    zs'              = merge   xs ys</div>
</div>

<div id="Merge Sort" class="hwex">
<p><br />
<strong>Exercise: (Merge Sort): </strong>Once you write the correct type
for <code>merge</code> above, you should be able to prove the unexpected
signature for <code>mergeSort</code> below.</p>
<ol type="1">
<li><p>Make sure you are able verify the given signature.</p></li>
<li><p>Obviously we don’t want <code>mergeSort</code> to return the
empty list, so there’s a bug. Find and fix it, so that you
<em>cannot</em> prove that the output is empty, but <em>can</em> instead
prove that the output is <code>ListEq a xs</code>.</p></li>
</ol>
<br />
<br />

</div>
<div id="program-pane-25" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-25" class="programbox">{-@ mergeSort :: (Ord a) => xs:[a] -> ListEmp a @-}
mergeSort []  = []
mergeSort xs  = merge (mergeSort ys) (mergeSort zs)
  where
   (ys, zs)   = halve mid xs
   mid        = length xs `div` 2</div>
</div>

</section>
<section id="uniqueness" class="level2">
<h2>Uniqueness</h2>
<p>Often, we want to enforce the invariant that a particular collection
contains <em>no duplicates</em>; as multiple copies in a collection of
file handles or system resources can create unpleasant leaks. For
example, the <a href="http://xmonad.org/">xmonad</a> window manager
creates a sophisticated <em>zipper</em> data structure to hold the list
of active user windows and carefully maintains the invariant that that
the zipper contains no duplicates. Next, let’s see how to specify and
verify this invariant using LiquidHaskell, first for lists, and then for
a simplified zipper.</p>
<p><br />
<strong>To Specify Uniqueness</strong> we need a way of saying that a
list has <em>no duplicates</em>. There are many ways to do so; the
simplest is a <em>measure</em>:</p>
<div id="program-pane-26" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-26" class="programbox">{-@ measure unique @-}
unique        :: (Ord a) => [a] -> Bool
unique []     = True
unique (x:xs) = unique xs && not (member x (elts xs))</div>
</div>

<p>We can use the above to write an alias for duplicate-free lists</p>
<div id="program-pane-27" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-27" class="programbox">{-@ type UList a = {v:[a] | unique v }@-}</div>
</div>

<p>Lets quickly check that the right lists are indeed
<code>unique</code></p>
<div id="program-pane-28" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-28" class="programbox">{-@ isUnique    :: UList Int @-}
isUnique = [1, 2, 3]           -- accepted by LH

{-@ isNotUnique :: UList Int @-}
isNotUnique = [1, 2, 3, 1]     -- rejected by LH</div>
</div>

<p><br />
<strong>The Filter</strong> function returns a <em>subset</em> of its
elements, and hence, <em>preserves</em> uniqueness. That is, if the
input is unique, the output is too:</p>
<div id="program-pane-29" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-29" class="programbox">{-@ filter   :: (a -> Bool)
             -> xs:UList a
             -> {v:ListSub a xs | unique v}
  @-}
filter _ []   = []
filter f (x:xs)
  | f x       = x : xs'
  | otherwise = xs'
  where
    xs'       = filter f xs</div>
</div>

<div id="Filter" class="hwex">
<p><br />
<strong>Exercise: (Filter): </strong>It seems a bit draconian to require
that <code>filter</code> only be called with unique lists. Write down a
more permissive type for <code>filter'</code> below such that the
subsequent uses are verified by LiquidHaskell.</p>
<br />
<br />

</div>
<div id="program-pane-30" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-30" class="programbox">filter' _ []   = []
filter' f (x:xs)
  | f x       = x : xs'
  | otherwise = xs'
  where
    xs'       = filter' f xs

{-@ test3 :: UList _ @-}
test3     = filter' (> 2) [1,2,3,4]

{-@ test4 :: [_] @-}
test4     = filter' (> 3) [3,1,2,3]</div>
</div>

<div id="Reverse" class="hwex">
<p><br />
<strong>Exercise: (Reverse): </strong>When we <code>reverse</code> their
order, the set of elements is unchanged, and hence unique (if the input
was unique). Why does LiquidHaskell reject the below? Can you fix things
so that we can prove that the output is a <code>UList a</code>? (When
you are done, you should be able to remove the <code>assume</code> from
the signature below, and still have LH verify the code.)</p>
<br />
<br />

</div>
<div id="program-pane-31" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-31" class="programbox">{-@ assume reverse    :: xs:UList a -> UList a    @-}
reverse :: [a] -> [a]
reverse         = go []
  where
    {-@ go     :: acc:[a] -> xs:[a] -> [a] @-}
    go acc []     = acc
    go acc (x:xs) = go (x:acc) xs</div>
</div>

<p><br />
<strong>The Nub</strong> function constructs a <code>unique</code> list
from an arbitrary input by traversing the input and tossing out elements
that are already <code>seen</code>:</p>
<div id="program-pane-32" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-32" class="programbox">{-@ nub              :: [a] -> UList a @-}
nub xs                = go [] xs
  where
    {-@ go :: UList a -> xs:[a] -> UList a / [len xs] @-}
    go seen []        = seen
    go seen (x:xs)
      | x `isin` seen = go seen     xs
      | otherwise     = go (x:seen) xs</div>
</div>

<p>The key membership test is done by <code>isin</code>, whose output is
<code>True</code> exactly when the element is in the given list. <a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a></p>
<div id="program-pane-33" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-33" class="programbox">-- FIXME
{-@ predicate In X Xs = Set_mem X (elts Xs) @-}

{-@ isin :: x:_ -> ys:_ -> {v:Bool | v <=> In x ys }@-}
isin x (y:ys)
  | x == y    = True
  | otherwise = x `isin` ys
isin _ []     = False</div>
</div>

<div id="Append" class="hwex">
<p><br />
<strong>Exercise: (Append): </strong>Why does <code>append</code>ing two
<code>UList</code>s not return a <code>UList</code>? Fix the type
signature below so that you can prove that the output is indeed
<code>unique</code>.</p>
<br />
<br />

</div>
<div id="program-pane-34" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-34" class="programbox">{-@ append       :: UList a -> UList a -> UList a @-}
append []     ys = ys
append (x:xs) ys = x : append xs ys</div>
</div>

<div id="Range" class="hwex">
<p><br />
<strong>Exercise: (Range): </strong><code>range i j</code> returns the
list of <code>Int</code> between <code>i</code> and <code>j</code>.
LiquidHaskell refuses to acknowledge that the output is indeed a
<code>UList</code>. Fix the code so that LiquidHaskell verifies that it
implements the given signature (and of course, computes the same
result.)</p>
<br />
<br />

</div>
<div id="program-pane-35" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-35" class="programbox">{-@ type Btwn I J = {v:_ | I <= v && v < J} @-}

{-@ range     :: i:Int -> j:Int -> UList (Btwn i j) @-}
range i j
  | i < j     = i : range (i + 1) j
  | otherwise = []</div>
</div>

<p><strong>Hint: </strong>This may be easier to do <em>after</em> you
read this chapter <a href="#lemmas">about lemmas</a>.</p>
</section>
<section id="unique-zippers" class="level2">
<h2>Unique Zippers</h2>
<p>A <a href="wiki-zipper">zipper</a> is an aggregate data structure
that is used to arbitrarily traverse the structure and update its
contents. For example, a zipper for a list is a data type that contains
an element (called <code>focus</code>) that we are currently
<code>focus</code>-ed on, a list of elements to the <code>left</code> of
(i.e. before) the focus, and a list of elements to the
<code>right</code> (i.e. after) the focus.</p>
<div id="program-pane-36" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-36" class="programbox">data Zipper a = Zipper {
    focus  :: a
  , left   :: [a]
  , right  :: [a]
  }</div>
</div>

<p><br />
<strong>xmonad</strong> is a wonderful tiling window manager, that uses
a <a
href="http://hackage.haskell.org/package/xmonad-0.11/docs/XMonad-StackSet.html">zipper</a>
to store the set of windows being managed. xmonad requires the crucial
invariant that the values in the zipper be unique, that is, be free of
duplicates.</p>
<p><br />
<strong>We Refine Zipper</strong> to capture the requirement that legal
zippers are unique. To this end, we state that the <code>left</code> and
<code>right</code> lists are unique, disjoint, and do not contain
<code>focus</code>.</p>
<div id="program-pane-37" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-37" class="programbox">{-@ data Zipper a = Zipper {
      focus :: a
    , left  :: {v: UList a | not (In focus v)}
    , right :: {v: UList a | not (In focus v) && Disj v left }
    } @-}

{-@ predicate Disj X Y = Disjoint (elts X) (elts Y)        @-}</div>
</div>

<p><br />
<strong>Our Refined Zipper Constructor</strong> makes <em>illegal states
unrepresentable</em>. That is, by construction, we will ensure that
every <code>Zipper</code> is free of duplicates. For example, it is
straightforward to create a valid <code>Zipper</code> from a
<code>unique</code> list:</p>
<div id="program-pane-38" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-38" class="programbox">{-@ differentiate    :: UList a -> Maybe (Zipper a) @-}
differentiate []     = Nothing
differentiate (x:xs) = Just $ Zipper x [] xs</div>
</div>

<div id="Deconstructing Zippers" class="hwex">
<p><br />
<strong>Exercise: (Deconstructing Zippers): </strong>Dually, the
elements of a unique zipper tumble out into a unique list. Strengthen
the types of <code>reverse</code> and <code>append</code> above so that
LiquidHaskell accepts the below signatures for
<code>integrate</code>:</p>
<br />
<br />

</div>
<div id="program-pane-39" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-39" class="programbox">{-@ integrate            :: Zipper a -> UList a @-}
integrate (Zipper x l r) = reverse l `append` (x : r)</div>
</div>

<p><br />
<strong>We can Shift the Focus</strong> element to the left or right
while preserving the uniqueness invariant. Here’s the code that shifts
the focus to the left:</p>
<div id="program-pane-40" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-40" class="programbox">focusLeft                      :: Zipper a -> Zipper a
focusLeft (Zipper t (l:ls) rs) = Zipper l ls (t:rs)
focusLeft (Zipper t [] rs)     = Zipper x xs []
  where
    (x:xs)                     = reverse (t:rs)</div>
</div>

<p>To shift to the right, we simply <em>reverse</em> the elements and
shift to the left:</p>
<div id="program-pane-41" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-41" class="programbox">focusRight    :: Zipper a -> Zipper a
focusRight    = reverseZipper . focusLeft . reverseZipper

reverseZipper :: Zipper a -> Zipper a
reverseZipper (Zipper t ls rs) = Zipper t rs ls</div>
</div>

<p><br />
<strong>To Filter</strong> elements from a zipper, we need to take care
when the <code>focus</code> itself, or all the elements get eliminated.
In the latter case, there is no <code>Zipper</code> and so the operation
returns a <code>Maybe</code>:</p>
<div id="program-pane-42" class="welleditor" style="background:#fff; position:relative">

  <!-- Verify Source -->
  <button class="btn btn-xs btn-link actbutton" type="button" style="z-index:1"
          ng-show="isUnknown" ng-click="verifySource()">
    <span class="glyphicon glyphicon-play"></span>
  </button>
 
  <div id="program-42" class="programbox">filterZipper :: (a -> Bool) -> Zipper a -> Maybe (Zipper a)
filterZipper p (Zipper f ls rs)
  = case filter p (f:rs) of
      f':rs' -> Just $ Zipper f' (filter p ls) rs'
      []     -> case filter p ls of
                  f':ls' -> Just $ Zipper f' ls' []
                  []     -> Nothing</div>
</div>

<p>Thus, by using LiquidHaskell’s refinement types, and the SMT solvers
native reasoning about sets, we can ensure the key uniqueness invariant
holds in the presence of various tricky operations that are performed
over <code>Zipper</code>s.</p>
</section>
<section id="recap" class="level2">
<h2>Recap</h2>
<p>In this chapter, we saw how SMT solvers can let us reason precisely
about the actual <em>contents</em> of data structures, via the theory of
sets. In particular, we saw how to:</p>
<ul>
<li><p><em>Lift set-theoretic primitives</em> to refined Haskell
functions from the <code>Data.Set</code> library,</p></li>
<li><p><em>Define measures</em> like <code>elts</code> that characterize
the set of elements of structures, and <code>unique</code> that describe
high-level application specific properties about those sets,</p></li>
<li><p><em>Specify and verify</em> that implementations enjoy various
functional correctness properties, e.g. that sorting routines return
permutations of their inputs, and various zipper operators preserve
uniqueness.</p></li>
</ul>
<p>Next, we present a variety of longer <em>case-studies</em> that
illustrate the techniques developed so far on particular application
domains.</p>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>See <a
href="https://ucsd-progsys.github.io/liquidhaskell-blog/2013/03/26/talking-about-sets.lhs/">this</a>
for a brief description of how to work directly with the set operators
natively supported by LiquidHaskell.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>See <a
href="http://research.microsoft.com/en-us/um/people/leonardo/fmcad09.pdf">this
recent paper</a> to learn how modern SMT solvers prove equalities like
the above.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The <a href="https://github.com/LeventErkok/sbv">SBV</a>
and <a href="http://lara.epfl.ch/w/leon">Leon</a> projects describe a
different DSL based approach for using SMT solvers from Haskell and
Scala respectively.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Since we are focusing on the elements, let’s not
distract ourselves with the <a href="#orderedlists">ordering
invariant</a> and reuse plain old lists. See <a
href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/07/29/putting-things-in-order.lhs/">this</a>
for how to specify and verify order with plain old lists.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Which should be clear by now, if you did a certain
exercise above .<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</div>
</div>

<div class="hidden">
<!--Site Meter -->
  <script type="text/javascript" src="//s23.sitemeter.com/js/counter.js?site=s23liquidtypes"></script>
  <noscript>
    <a href="http://s23.sitemeter.com/stats.asp?site=s23liquidtypes" 
      target="_top">
      <img src="http://s23.sitemeter.com/meter.asp?site=s23liquidtypes" 
      alt="Site Meter" border="0"/></a>
  </noscript>
  <!-- Copyright (c)2009 Site Meter -->
</div>





<!-- JavaScript below! ============================================== -->

  <script src="./js/ace/ace.js" type="text/javascript" charset="utf-8"></script> 
  <script src="./js/ace/theme-monokai.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/ace/mode-haskell.js"  type="text/javascript" charset="utf-8"></script>
  <script src="./js/liquid/tooltip.js"></script> 
  <script src="./js/liquid/annot.js"></script> 
  <script src="./js/liquid/config.js"></script> 
  <script src="./js/liquid/liquid.js"></script>

  <script type="text/javascript">
    var queryServerURL = "https://liquid-demo.programming.systems/" ;
  </script>
  
  <!-- rust nav JS --> 
  <script type="text/javascript">
    window.playgroundUrl = "";
  </script>
  
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {

 document.getElementById("toggle-nav").onclick = toggleNav;

  function toggleNav() {
    var toc         = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    var status      = document.getElementById("checker-status");

    toggleClass(toc,         "mobile-hidden");
    // toggleClass(status,      "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }
       el.className = classes.join(' ');
     }
  }
});
</script>
</body>
</html>
